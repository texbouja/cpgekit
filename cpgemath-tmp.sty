\def\filedate{2023/10/26}
\def\fileversion{v0.1alpha}
\def\fileauthor{Sadik Boujaida}

\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{cpgemath}[\filedate\space\fileversion]

\RequirePackage{etoolbox}
\RequirePackage{pgfkeys}
\RequirePackage{calc}
\RequirePackage{xparse}
\RequirePackage{xstring}

\RequirePackage{mathtools}
\RequirePackage{amsthm}
\RequirePackage{varwidth}
\RequirePackage{mleftright}

\def\cpgemath@err#1{\PackageError{cpgemath}{\MessageBreak#1}}
\def\cpgemath@warn#1{\PackageWarning{cpgemath}{\MessageBreak#1}}

\AtEndPreamble{
\ifundef{\iftx@sbc}{}
	{\iftx@sbc\cpgemath@err
		{cpgemath est incompatible avec l'option subscriptcorrection de newtxmath}
		{cpgemath offre une alternative à l'option subscriptcorrection, 
		\MessageBreak voir le manuel}
	\fi}
\if@fleqn
	\cpgemath@err
		{cpgemath n'est pas compatible (pour l'instant) avec l'option 
		\MessageBreak fleqn d'amsmath}
		{Vous pouvez continuer à utiliser cpgemath avec l'option 
		\MessageBreak fleqn d'amsmath si vous n'utilisez pas 
		\MessageBreak l'environnement xalign}
\fi	
}

%%%% Si certains caracteres ne sont pas encore definis a 
%%%% la fin du preambule, emprunter a fourier.sty 
\AtEndPreamble{
	\@ifundefined{lVERT}{
		\DeclareFontEncoding{FMS}{}{}
  		\DeclareFontSubstitution{FMS}{futm}{m}{n}
		\DeclareFontEncoding{FMX}{}{}
 			\DeclareFontSubstitution{FMX}{futm}{m}{n}
		\DeclareSymbolFont{futsymbols}{FMS}{futm}{m}{n}
		\DeclareSymbolFont{futlargesymbols}{FMX}{futm}{m}{n}
		\DeclareSymbolFont{futoperators}{T1}{futs}{m}{n}%
		\DeclareMathDelimiter{\lBrack}
				{\mathopen}{futsymbols}{153}{futlargesymbols}{133}
		\DeclareMathDelimiter{\rBrack}
				{\mathclose}{futsymbols}{154}{futlargesymbols}{134}
		\DeclareMathDelimiter{\Vert}
   			{\mathord}{futsymbols}{107}{futlargesymbols}{176}
		\DeclareMathDelimiter{\VERT}
   			{\mathord}{futsymbols}{152}{futlargesymbols}{147}
		\DeclareMathDelimiter{\vert}
   			{\mathord}{futsymbols}{106}{futlargesymbols}{175}
		\DeclareMathDelimiter{\lvert}
    		{\mathopen}{futsymbols}{106}{futlargesymbols}{175}
		\DeclareMathDelimiter{\rvert}
    		{\mathclose}{futsymbols}{106}{futlargesymbols}{175}
		\DeclareMathDelimiter{\lVert}
  			{\mathopen}{futsymbols}{107}{futlargesymbols}{176}
		\DeclareMathDelimiter{\rVert}
    		{\mathclose}{futsymbols}{107}{futlargesymbols}{176}
		\DeclareMathDelimiter{\lVERT}
  			{\mathopen}{futsymbols}{152}{futlargesymbols}{147}
		\DeclareMathDelimiter{\rVERT}
    		{\mathclose}{futsymbols}{152}{futlargesymbols}{147}
		\DeclareMathAccent{\mathring}{\mathalpha}{futoperators}{6}
		\DeclareMathAccent{\wideparen}{\mathord}{futlargesymbols}{148}
		\DeclareMathAccent{\widearc}{\mathord}{futlargesymbols}{216}
		\DeclareMathAccent{\wideOarc}{\mathord}{futlargesymbols}{228}
		\let\widehat\undefined
    	\DeclareMathAccent{\widehat}{\mathord}{futlargesymbols}{98}
    	\let\widetilde\undefined
    	\DeclareMathAccent{\widetilde}{\mathord}{futlargesymbols}{101}
	}{}%
	\@ifundefined{leqslant}{\RequirePackage{amssymb}}{}
	\let\leq\leqslant
	\let\geq\geqslant
	\def\setminus{\!\smallsetminus\!}
	\@ifundefined{mathscr}
		{\RequirePackage[scr=boondoxo,frak=boondox,bb=boondox]{mathalfa}}
		{}
}
\AtBeginDocument{
	\ifundef{\widering}{
			\DeclareDocumentCommand{\widering}{m}{\overset{\smash{\vbox to .2ex{%
    			\hbox{$\mathring{}$}}}}{\wideparen{#1}}}%
		}{}%
}
%%%%% Commandes utilitaires
\def\cpge@expandtwoargs#1#2#3{\begingroup%
	\edef\cpge@tmpa{\endgroup\noexpand#1{#2}{#3}}\cpge@tmpa}
\def\cpge@expandfirstarg#1#2#3{\begingroup%
	\edef\cpge@tmpa{\endgroup\noexpand#1{#2}\unexpanded{#3}}\cpge@tmpa}
\def\cpge@expandsecondarg#1#2#3{\begingroup%
	\edef\cpge@tmpa{\endgroup\noexpand#1\unexpanded{#2}{#3}}\cpge@tmpa}
	
\ifcsundef{cpgesetdeco}{
	\def\cpgesetdeco{\@ifstar\cpge@deco@\cpge@deco}
	\long\def\@cpge@deco#1#2{
 	 	\csdef{deco@#2}##1{\begingroup#1\endgroup}}
	\long\def\@cpge@deco@#1#2{
 	 \csdef{deco@#2}{#1}}
	\long\def\cpge@deco#1#2{\forcsvlist{\@cpge@deco{#2}}{#1}}
	\long\def\cpge@deco@#1#2{\forcsvlist{\@cpge@deco@{#2}}{#1}}
}{}
	
\long\def\fake@cmd#1{#1}

\newcommand\@ifisnumber[1]{%
        \begingroup
        \edef\temp@{#1}%
        \@xp\ifstrempty\@xp{\temp@}
                {\endgroup\@secondoftwo}
                {\@xp\if@number@i\temp@\@nnil}%
}
\def\if@number@i#1#2\@nnil{%
        \if-#1%
                \gdef\temp@s{-}
                \ifstrempty{#2}
                        {\def\temp@{X}}
                        {\def\temp@{#2}}%
        \else
                \gdef\temp@s{+}
                \def\temp@{#1#2}%
        \fi
        \xdef\temp@n{\temp@}
        \afterassignment\if@numhelper
        \count@0\temp@\relax\@nnil
        \endgroup
}

\def\num@relax{\relax}%
\def\if@numhelper#1\@nnil{%
        \def\temp@{#1}%
        \ifx\temp@\num@relax
                \aftergroup\@firstoftwo
        \else
                \aftergroup\@secondoftwo
        \fi
}

\def\is@num#1#2#3{%
  \if!\ifnum9<1#1!\else_\fi
    #3\else#2\fi
  }


%%%%% Interface de configuration pgfkeys
\ifundef\cpgesetup
    {
		\pgfkeysifdefined{/cpge/.is family}{}{\pgfkeys{/cpge/.is family}}
		\NewDocumentCommand\cpgesetup{o}{%
    	\IfValueT{#1}
    		{\pgfkeysifdefined{/cpge/#1/.is family}{}
				{\pgfkeys{/cpge/#1/.is family}}}%
    	\IfValueTF{#1}{\pgfqkeys{/cpge/#1}}{\pgfqkeys{/cpge}}%
    	}
	\pgfkeysdef{/handlers/.set}{\pgfkeysdef{\pgfkeyscurrentpath}{#1}}
	}{}

\cpgesetup{math/.is family}
\NewDocumentCommand\cpgesetupmath{o}{%
    	\IfValueT{#1}
    		{\pgfkeysifdefined{/cpge/math/#1/.is family}{}
				{\pgfkeys{/cpge/math/#1/.is family}}}%
    	\IfValueTF{#1}{\pgfqkeys{/cpge/math/#1}}{\pgfqkeys{/cpge/math}}%
    	}
\cpgesetup{math/symbols/.is family}

\cpgesetupmath{
	@interval/.is family,
	@interval/separator/.code		= \def\IntSep{#1},
	@interval/space/.code 			= \def\IntSpace{#1},
	@inner product/.is family,
	@inner product/space/.code		= \def\SprodSep{#1},
	@inner product/separator/.code	= \def\SprodSpace{#1},
	@given/.is family,
	@given/separator/.code			= \def\GivenSep{#1},
	@given/space/.code				= \def\GivSpace{#1},			
	@transpose/.is family,
	@transpose/position/.is choice,
	@transpose/position/left/.code	= \def\trans{\ltrans},
	@transpose/position/right/.code	= \def\trans{\rtrans},
	@transpose/l/.style				= {transpose/position=left},
	@transpose/r/.style				= {transpose/position=right},
	@transpose/left kern/.code 		= \def\transpose@leftkern{#1},
	@transpose/right kern/.code 	= \def\transpose@rightkern{#1},
	interval/.code					= \pgfqkeys{/cpge/math/@interval}{#1},
	inner product/.code				= \pgfqkeys{/cpge/math/@inner product}{#1},
	given/.code						= \pgfqkeys{/cpge/math/@given}{#1},
	transpose/.code					= \pgfqkeys{/cpge/math/@transpose}{#1}
}

\def\cpgesetsymbol#1#2{
	\ifcsundef{#1symb}
		{\cpgesetupmath[symbols]{#1/.code=\csdef{#1symb}{{##1}}}}
		{}%
	\cpgesetupmath[symbols]{#1=#2}
}

\cpgesetupmath{%
	symbols/.is family,
	symbol/.code = \pgfqkeys{/cpge/math/symbols}{#1},
	symbols/.cd, 
	M/.code	= \def\Msymb{{#1}},
	B/.code = \def\Bsymb{{#1}},
	S/.code	= \def\Ssymb{{#1}},
	L/.code	= \def\Lsymb{{#1}},
	P/.code	= \def\Psymb{{#1}},
	E/.code	= \def\Esymb{{#1}},
	V/.code	= \def\Vsymb{{#1}},
	O/.code	= \def\Osymb{{#1}},
	o/.code	= \def\osymb{{#1}},
	Cl/.code= \def\Clsymb{{#1}},
	lt/.code= \def\ltsymb{{#1}},
	rt/.code= \def\rtsymb{{#1}},
	e/.code	= \def\esymb{{#1}},
	i/.code	= \def\isymb{{#1}},
	d/.code	= \def\dsymb{{#1}},
	D/.code	= \def\Dsymb{{#1}},
	N/.code	= \def\Nsymb{{#1}},
	Z/.code	= \def\Zsymb{{#1}},transpose/l/.style				={transpose/position=l},
	Q/.code	= \def\Qsymb{{#1}},
	R/.code	= \def\Rsymb{{#1}},
	C/.code	= \def\Csymb{{#1}},
	K/.code	= \def\Ksymb{{#1}},
	1/.code= \csdef{1symb}{{#1}},
	corps/.code =\def\corpssymb{\csuse{#1symb}},
	dim/.code = \def\dimsymb{{#1}},
}
\cpgesetupmath{
	interval={separator={;}},
	inner product={separator={;}},
	given={separator=\vert},
	given={space=9mu},
%	transpose/position=left,
	transpose={left kern=0},
	transpose={right kern=0},
}
\cpgesetupmath{symbol={
	M=\mathcal M,
	B=\mathscr B,
	S=\mathcal S,
	L=\mathcal L,
	P=\mathbf P,
	E=\mathbf E,
	V=\mathbf V,	
	O=\mathcal O,
	o=\mathrm o,
	Cl=\mathscr C,
	lt=\mathsf t,
	rt=\mathsf T,
	e={\operator@font e},
	d={\operator@font d},
	D={\operator@font D},
	i=\mathbf{i},
	N=\mathbb{N},
	Z=\mathbb{Z},
	Q=\mathbb{Q},
	R=\mathbb{R},
	C=\mathbb{C},
	K=\mathbb{K},
	corps=K,
	dim=n,
	1=\mathbf{1}
}}
%%%% Raccourcis 

\DeclareRobustCommand{\opn}{\operatorname}
\def\symb#1{\opn{\csuse{#1symb}}}
\DeclareRobustCommand\diff{\mkern2.4mu\dsymb}
\DeclareRobustCommand\Diff{\opn{\Dsymb}}
\DeclareRobustCommand\e{\opn{\esymb}}
\def\vnabla{\boldsymbol\nabla}
\DeclareRobustCommand{\N}{\Nsymb}
\DeclareRobustCommand{\Z}{\Zsymb}
\DeclareRobustCommand{\Q}{\Qsymb}
\DeclareRobustCommand{\R}{\Rsymb}
\DeclareRobustCommand{\C}{\Csymb}
\DeclareRobustCommand{\K}{\Ksymb}
\DeclareMathSymbol{\vphi}{\mathord}{letters}{"27}
\DeclareMathSymbol{\veps}{\mathord}{letters}{"22}
\DeclareRobustCommand{\Chi}{{\mathpalette\c@chi\relax}}
\newcommand{\c@chi}[2]{\raisebox{\depth}{$#1\chi$}}
\DeclareRobustCommand\bfone{\opn{\csname 1symb\endcsname}}

\NewDocumentCommand\ltrans{sO{\transpose@leftkern} m}
	{\,\vphantom{#3}^{\ltsymb}\mkern#2mu#3}
\NewDocumentCommand\rtrans{sO{\transpose@rightkern} m}
	{#3\mkern#2mu^{\rtsymb}\,}
\NewDocumentCommand\trans{som}{%
	\IfBooleanTF{#1}
		{\IfValueTF{#2}{\rtrans[#2]{#3}}{\rtrans{#3}}}
		{\IfValueTF{#2}{\ltrans[#2]{#3}}{\ltrans{#3}}}
}
\def\grad{\opn{\vnabla}}
\NewDocumentCommand\B{O{B}}{\mathcal #1}
\NewDocumentCommand\Id{o}{\IfValueTf{#1}{\opn{id}_{#1}}{\opn{id}}}
\NewDocumentCommand\diag{sm}{%
	\IfBooleanFT{#1}
		{\begingroup\let\dots\ldots\opn{diag}{\left(#2\right)}\endgroup}
		{\begingroup\let\dots\ddots%
			\begin{pmatrix}\matrix@construct{#2}\end{pmatrix}%
		\endgroup}
}
%%% Acronymes

\RequirePackage{acronym}
%\RequirePackage{acro}
% \acsetup{
% 	list/display=used,
% 	list/template=description,
% 	pages/display=first,
% 	format/short=\sffamily\scshape,
% 	format/long=\sffamily,
% }
% \def\listofacronyms{\printacronyms}


\renewcommand\acsfont[1]{\textsf{\scshape #1}}
\renewcommand\acffont[1]{\textsf{#1}}
\def\acro@@{\newacro}
\def\acro@@plural{\newacroplural}

\acro@@				{vap}{valeur propre}
\acro@@plural		{vap}{valeurs propres}
\acro@@				{vep}{vecteur propre}
\acro@@plural		{vep}{vecteurs propres}
\acro@@				{sep}{sous-espace propre}
\acro@@plural		{sep}{sous-espaces propres}
\acro@@				{sev}{sous-espace vectoriel}
\acro@@plural		{sev}{sous-espaces vectoriels}
\acro@@				{evn}{espace vectoriel norm\'e}
\acro@@plural		{evn}{espaces vectoriels norm\'es}
\acro@@				{cpa}{connexe par arcs}
\acro@@plural		{cpa}{connexes par arcs}
\acro@@				{uc}{uniform\'ement continue}
\acro@@				{uce}[uc]{uniform\'ement continue}
\acro@@plural		{uc}{uniform\'ement continues}
\acro@@				{bon}{base orthonorm\'ee}
\acro@@plural		{bon}{bases orthonorm\'ees}
\acro@@				{pgcd}{plus grand dviseur commun}
\acro@@				{ppcm}{plus petit multiple commun}
\acro@@				{de}{division euclidienne}
\acro@@				{cvs}{converge simplement}
\acro@@				{cves}[cvs]{convergence simple}
\acro@@				{cva}{converge absolument}
\acro@@				{cvea}[cva]{convergence absolue}
\acro@@				{cvu}{converge uniform\'ement}
\acro@@				{cveu}[cvu]{convergence uniforme}
\acro@@				{cvuc}{converge uniformément sur tout compact}
\acro@@				{cveuc}[cvuc]{convergence uniforme sur tout compact}
\acro@@				{cvn}{converge normalement}
\acro@@				{cven}[cvn]{convergence normale}
\acro@@				{dse}{d\'eveloppable en s\'erie enti\`ere}
\acro@@				{rc}{rayon de convergence}
\acro@@plural		{rc}{rayons de convergence}
\acro@@				{cpm}{continue par morceaux}
\acro@@plural		{cpm}{continues par morceaux}
\acro@@				{cepm}{continuit\'e par morceaux}
\acro@@				{va}{variable al\'eatoire}
\acro@@				{var}{variable al\'eatoire r\'eelle}
\acro@@				{vad}{variable al\'eatoire discrète}
\acro@@				{vadr}{variable al\'eatoire discr\`ete r\'eelle}
\acro@@				{eaf}{\'egalit\'e des accroissements finis}
\acro@@				{iaf}{in\'egalit\'e des accroissements finis}
\acro@@				{ics}{in\'egalit\'e de Cauchy-Schwarz}
\acro@@				{ipp}{int\'egration par parties}
\acro@@				{itt}{int\'egration terme \`a terme}
\acro@@				{dtt}{d\'erivation terme \`a terme}
\acro@@				{il}{interversion de limites}
\acro@@				{cvd}{convergence domin\'ee}
\acro@@				{tdn}{th\'eor\`eme de la d\'ecomposition des noyax}
\acro@@				{tch}{th\'eor\`eme de Cayley-Hamilton}
\acro@@				{tsp}{th\'eor\`eme spectral}
\acro@@				{tcd}{th\'eor\`eme de la convergence domin\'ee}
\acro@@				{til}{th\'eor\`eme d'interversion de limites}
\acro@@				{tdtt}{th\'eor\`eme de d\'erivation terme \`a terme}
\acro@@				{titt}{th\'eor\`eme d'int\'egration terme \`a terme}
\acro@@				{tvi}{th\'eor\`eme des valeurs int\'erm\'ediaires}
\acro@@				{ticc}{th\'eor\`eme de l'image continue d'un compact}
\acro@@				{cscsa}{critère spécial de convergence des séries altérnées}


\RequirePackage{xspace}
\def\vap{\ac{vap}\xspace}
\def\vep{\ac{vep}\xspace}
\def\sev{\ac{sev}\xspace}
\def\sep{\ac{sep}\xspace}
\def\cvs{\ac{cvs}\xspace}
\def\cvu{\ac{cvu}\xspace}
\def\cvuc{\ac{cvuc}\xspace}
\def\cvn{\ac{cvn}\xspace}
\def\rc{\ac{rc}\xspace}
\def\cpm{\ac{cpm}\xspace}
\def\dse{\ac{dse}\xspace}
\def\var{\ac{var}\xspace}
\def\vad{\ac{vad}\xspace}
\def\vadr{\ac{vadr}\xspace}
%%%%%%

%%%%% Déclarations

\newbox\cpgem@boxa
\newbox\cpgem@boxb
\newbox\cpgem@boxc

\newdimen\cpge@dima
\newdimen\cpge@dimb
\newdimen\cpge@dimc
\newcount\cpge@count
\newcount\cpge@loop
\newcount\eqn@count@
\newcount\dlm@count@

\newif\iftextmode
\newif\ifeqn@number 
\newif\ifis@result
\newif\ifcpge@minipage
\newif\ifcpge@indisplay
\ifundef{\ifcompact}{\newif\ifcompact}{}

%%%%%%%%%
%%% le système \xsave
\listadd\cpgesaved@list{@@@}
\NewDocumentCommand\x@save{sm+m}{#3}
\NewDocumentCommand\xsave{sm+m}{%
	\begingroup
	\def\xsave{\x@save}
	\ifmeasuring@\else
		\ifcsdef{saved@#2}
			{\cpgesave@err{#2}{déjà utilisé}}
			{%
				\csgdef{saved@#2}{#3}%
				\listgadd\cpgesaved@list{#2}%
			}
	\fi
	\IfBooleanF{#1}{#3}%
	\endgroup
}
\NewDocumentCommand\xsaved{m}{%
	\ifmeasuring@
		\csuse{saved@#1}
	\else
		\ifcsundef{saved@#1}
			{\cpgesave@err{#1}{non trouvé}}
			{\csuse{saved@#1}}
	\fi
}
\NewDocumentCommand\DeleteSaved{o}{%
	\begingroup%
	\def\do##1{%
		\csgundef{saved@##1}%
		\listgremove\cpgesaved@list{##1}%
	}%
	\IfValueTF{#1}
		{%
			\forcsvlist{\listadd\cpgetmpsaved@list}{#1}
			\dolistloop\cpgetmpsaved@list
		}
		{\dolistloop\cpgesaved@list}
	\makeatletter
		\listgadd\cpgesaved@list{@@@}
	\makeatother
	\endgroup
}
\def\cpgesave@err#1#2{\cpgemath@err{enregistrement #1\space #2}{}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%g%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%% Formules mathématiques %%%%%%%%%%%%%%%%%%%%%

% registres permanents pour la famille \formula
\newbox\midbox % boite qui contient le texte central dans \@center@
\newdimen\midwidth % largeur de cette boite
\newskip\bigcenterskip %grand espace vertical avant et après \@center@
\newskip\medcenterskip % espace vertical moyen avant et après \@center@
\newskip\smallcenterskip %petit espace, si \@center@ imbriqué
\newcount\precenterpenalty 
\newcount\postcenterpenalty
\newdimen\fadjwidth % reçoit l'excédent de largeur ajouté par le cadre

\def\numvskip{\dimexpr\medcenterskip*1/2\relax}
\AtBeginDocument{
	\bigcenterskip=8\p@ \@plus 2\p@ \@minus 4\p@
	\medcenterskip=6\p@ \@plus 2\p@ \@minus 3\p@
	\smallcenterskip=\z@  \@plus 3\p@
	\abovedisplayskip\bigcenterskip\relax%
	\belowdisplayskip\bigcenterskip\relax%
	\abovedisplayshortskip\medcenterskip\relax%
	\belowdisplayshortskip\medcenterskip\relax
}
\precenterpenalty\@highpenalty 
\postcenterpenalty\z@

%%%% Quelques commandes utilitaires %%%%
\def\m@cpge@par{\par\nointerlineskip}
\def\m@cpge@narrowpar{\rightskip \z@ \@plus .5em 
 	 \@rightskip\rightskip \parfillskip\z@ \@plus .1\hsize}  
\def\m@cpge@noindent{\everypar{{\setbox\z@\lastbox}}}
\def\endpar{\ifhmode\unskip\nobreak\hfill\m@cpge@stop\fi}
\let\cpge@ifnextchar\new@ifnextchar


%%%% Quelques commandes utilitaires %%%%
\def\m@cpge@stop{\vrule\@width\z@}
\def\m@cpge@par{\par\nointerlineskip}
\def\m@cpge@narrowpar{\rightskip \z@ \@plus .5em 
 	 \@rightskip\rightskip \parfillskip\z@ \@plus .1\hsize}  
\def\m@cpge@noindent{\everypar{{\setbox\z@\lastbox}}}
\def\endpar{\ifhmode\unskip\nobreak\hfill\m@cpge@stop\fi}
\newcommand\xtag[1][]{%
	\tag*{(\theequation)}\refstepcounter{equation}%
	\ifblank{#1}{}{\label{#1}}%
	}
\@ifpackageloaded{xcolor}{}{\RequirePackage{xcolor}}{}
\colorlet{framecol}{black!66}
\colorlet{backcol}{black!18}
\long\def\fancyb@x#1{%
	\fboxsep\z@\fboxrule1.2\p@%
	\fcolorbox{framecol}{white}{%
		\fboxsep3\p@\fboxrule0.8\p@\fcolorbox{white}{backcol}
		{\kern1em#1\kern1em}%
	}%
}
\cpgesetupmath{
	formula/.code=\cpgesetdeco{formula}{#1},
	result/.code=\cpgesetdeco{result}{#1},
	r/.code=\cpgesetdeco{result}{#1},
	formula=\fbox{#1},
	result=\fancyb@x{#1},
}
\def\deco@r{\deco@result}
\def\decof{\deco@formula}

%%%% Nouveaux environnement pour les maths %%%%
%%%%  	Les commandes butineuses 	        %%%%
%%%% 	backends pour l'environnement xmath  et \< ... \> %%%%

%%%%% Triming space, from trimspaces.sty
%%%%% tribute to Will Robertson
\catcode`\Q=3
\newcommand\xtrimspaces[1]{%
  \romannumeral-`\q\xtrim@trim@\noexpand#1Q Q%
}
\long\def\xtrim@trim@#1 Q{\xtrim@trim@@#1Q}
\long\def\xtrim@trim@@#1Q#2{#1}
\catcode`\Q=11
\def\xtrimspaces@noexp#1{%
  \unexpanded\@xp\@xp\@xp
    {\xtrimspaces{#1}}%
}
\def\xtrimspaces@in#1{%
  \edef#1{\@xp\xtrimspaces@noexp\@xp{#1}}%
}
% Trimming preceding spaces:
\def\xtrim@pre@space#1{%
  \romannumeral-`\.\@xp\noexpand#1%
}
\def\xtrim@pre@space@noexp#1{%
  \unexpanded\@xp{%
    \romannumeral-`\.\@xp\noexpand#1%
  }%
}
\def\xtrim@pre@space@in#1{%
  \@xp\def\@xp#1\@xp{%
    \romannumeral-`\.\@xp\noexpand#1%
  }%
}
% Trimming trailing space:
\catcode`\Q=3
\def\xtrim@post@space#1{\xtrim@trim@#1Q Q}
\catcode`\Q=11

\def\xtrim@post@space@noexp#1{%
  \unexpanded\@xp\@xp\@xp
  \@xp\@xp\@xp\@xp
    {\xtrim@post@space{#1}}%
}
\def\xtrim@post@space@in#1{%
  \edef#1{\@xp\xtrim@post@space@noexp\@xp{#1}}%
}

%% \@center@ s'occupe du placement des éléments, 
%% esp. vert. et pénalités de rupture de page

\long\def\eqn@fakecmd#1{#1}
\let\eqnframecmd\eqn@fakecmd
\def\cpgeframe@err#1{\cpgemath@err
			{Aucune décoration #1 trouvée. 
			\MessageBreak Appuyez sur entrée pour l'ignorer}
			{les valeurs possibles sont formula (par défaut), \MessageBreak 
				result ou simplement r.}
		}

\long\def\eqn@prepareboxes#1#2#3{%
	\setbox\z@\hbox{\eqnframecmd{}}%
	\fadjwidth\wd\z@%
	\setbox\cpgem@boxa\hbox{%
		\color@begingroup#2\color@endgroup%
	}%
	\ifdim\wd\cpgem@boxa=\z@%
		\if@inlabel%
			\setbox\cpgem@boxa\hbox{\kern 1em}%
		\fi%
	\fi%
	\iftextmode%
		\eqn@preparemidbox{#1}{#3}%
		\setbox\cpgem@boxb\hbox{\cpge@indisplaytrue%
			\eqnframecmd{$\m@th%
				\vcenter{%
					\hsize\midwidth\@parboxrestore\box\midbox%
			}$}%
		}%
	\else%
		\setbox\cpgem@boxb\hbox{\cpge@indisplaytrue%
			\eqnframecmd{#3}%
	}%
	\fi%
	\setlength\cpge@dima{(\linewidth-\wd\cpgem@boxb)/2}%
	\unless\ifdim\cpge@dima<\z@%
		\setlength\cpge@dimb{\cpge@dima*(\l@qnshift-\r@qnshift)/10}%
		\setlength\cpge@dima{\cpge@dima+\cpge@dimb}%
		\setlength\cpge@dimc{\cpge@dima-\cpge@dimb}%
	\fi%
}
\def\mid@pos{[t]}
\long\def\eqn@preparemidbox#1#2{%
	\def\in@@{\in@{*!}}%
	\@xp\in@@\@xp{#1!}%
	\ifin@%
		\edef\num@pt{\cpge@removestar #1}%
		\let\@render\m@cpge@narrowpar% 
		\def\@renderer{varwidth}%
	\else%
		\def\num@pt{#1}%
		\let\@render\relax%
		\def\@renderer{minipage}%
	\fi%
	\ifnum\num@pt<50\relax%
		\ifnum\num@pt=0\relax%
			\midwidth\hsize%
		\else%
			\midwidth.5\hsize%
		\fi%
	\else%
		\setlength\midwidth{\hsize*\ratio{\num@pt\p@}{100\p@}}%
	\fi%
	\midwidth=\dimexpr\midwidth-\fadjwidth-2em\relax%
	\eqn@setmidbox{#2}%
	%\setlength\midwidth{\wd\midbox+\fadjwidth}%
}
\long\def\eqn@setmidbox#1{%
	\setbox\midbox\hbox{%
		\hbadness\@M\cpge@count\z@%
		\begin{\@renderer}\midwidth%
			\cpge@minipagetrue%
			\everymath{\displaystyle}%
			\abovedisplayskip\bigcenterskip%
			\belowdisplayskip\bigcenterskip%		
		 	%\par va compter le nombre de ligne dans la boite
		 	\@setpar{%
				\hfill{\@@par}\global\advance\cpge@count\prevgraf
				%\addvspace{\belowdisplayskip}
			}%
		 	\@render #1\hfill\null%
		\end{\@renderer}%
	}%
	%\midwidth\wd\midbox%
	%\setbox\midbox\vbox{\hsize\midwidth\unhbox\midbox}%
}
\def\hacked@item{%
	\item[]\@trivlist\@noparlistfalse\item[]\leavevmode%
}
\def\begin@center@{%
	\if@inlabel
		\vskip\bigcenterskip
	\fi%	
	\trivlist%\parindent\z@%
	\ifcpge@minipage%
		\@topsep\smallcenterskip%
		\partopsep\medcenterskip%
	\else%
		\@topsep\bigcenterskip%
		\partopsep\bigcenterskip%
	\fi%
	\@topsepadd\z@skip%
	\parsep\z@skip%
	\itemsep\medcenterskip%
	\@beginparpenalty\precenterpenalty%
	\@endparpenalty\postcenterpenalty%
}
\long\def\eqn@item#1#2#3#4#5{%
	\hacked@item%
	%\begingroup%
	\eqn@prepareboxes{#1}{#2}{#3}%
	\ifdim\wd\cpgem@boxa>\cpge@dima\relax%
		\ifhmode%
			\unskip\par\nobreak\vskip-\parskip\noindent%
		\fi%
		\unhbox\cpgem@boxa\par%
		\vskip-\lineskiplimit%
        \vskip\normallineskiplimit%
		\vskip\largetextbelow%
	\fi%
	\ifdim\wd\cpgem@boxa>\z@%
		\leavevmode\hb@xt@\z@{%
			\unhcopy\cpgem@boxa\hss%
		}%
	\fi%
	\setbox\cpgem@boxb\hbox{\kern\cpge@dimb\box\cpgem@boxb}%
	\ifdim\wd\cpgem@boxb>\linewidth%
		\hskip-\@totalleftmargin%
		\setbox\cpgem@boxb\hb@xt@\linewidth{\unhbox\cpgem@boxb}%
	\fi%
	\m@cpge@stop%
	\hskip\z@\@plus .5fill%
	\box\cpgem@boxb%
	\hskip\z@\@plus .5fill%
	\m@cpge@stop%
	\protected@edef\cpge@tmpl{#5}%
	\ifeqn@number%
		\refstepcounter{equation}%
		\setbox\cpgem@boxc\hbox{%
			\tag@kern\deco@tag{\theequation}%
		}%
		\unless\ifx\@empty\cpge@tmpl%
			\@xp\label\@xp{\cpge@tmpl}%
		\fi%
	\else%
		\ifx\@empty\cpge@tmpl%
			\setbox\cpgem@boxc\hbox{}%
		\else%
			\setbox\cpgem@boxc\hbox{\tag@kern\deco@tag{\cpge@tmpl}}%
		\fi%
	\fi%
	\ifdim\wd\cpgem@boxc>\z@\relax%
		\ifdim\cpge@dimc>\wd\cpgem@boxc\relax%
			\hb@xt@\z@{\hss\box\cpgem@boxc}%
			\setbox\cpgem@boxc\hbox{\xtrimspaces{#4}}%
			\ifdim\wd\cpgem@boxc>\z@%
				\m@cpge@par\nobreak\vskip\numvskip\hfill%
			\fi%
		\else%
			\setbox\cpgem@boxc\hbox{%
				\xtrimspaces{#4}\unhbox\cpgem@boxc%
			}%
			\m@cpge@par\nobreak\vskip\numvskip\hfill%
		\fi%\x@hackitem
	\else%
		\setbox\cpgem@boxc\hbox{\xtrimspaces{#4}}%
		\ifdim\wd\cpgem@boxc>\cpge@dimc%
			\m@cpge@par\nobreak\vskip\numvskip\hfill%
		\fi%
	\fi%
	\ifdim\wd\cpgem@boxc>\z@%
		\hb@xt@\z@{\hss\box\cpgem@boxc}%
	\fi%
	%\endgroup%
}
\def\@center@#1#2#3#4#5{%
	\begin@center@%
	\eqn@item%
		{#1} % width argument, used only if \iftextmode is true
		{#2} % left text
		{#3} % middle text
		{#4} % right text
		{#5}%% \label used only if \ifeqn@number is true
	\endtrivlist%
}

	
%%% Interfacce utilisateur (xparse) pour \@center@


\NewDocumentCommand\xmath@init{ 
		t\n % numbered or not 
		t\r % framed text mode for the mid part
		t\t % unframed text mode for the mid part
}{
	\let\eqnframecmd\eqn@fakecmd%
	\IfBooleanTF{#1}
		{\eqn@numbertrue}
		{\eqn@numberfalse}%
	\IfBooleanTF{#2}
		{\is@resulttrue}
		{\is@resultfalse}%
	\IfBooleanTF{#3}
		{\textmodetrue}
		{\textmodefalse}%
	\xmath@preprocess
}
\NewDocumentCommand\xmath@preprocess{
	E{
		\lt % #1 : left text
		\rt % #2 : right text
		\ls % #3 : left shift
		\rs % #4 : right shift 
		\fr % #5 : framed or not 
		\al % #6 : aligned or not 
		\wd % #7 : minipage width, sets \textmodetrue
		\lb % #8 : \label, if numbered
		\vs % #9 : skip to add to \bigcenterskip
	}{{}{}{}{}{@}{@}{}{}{}}
}{%
	\def\minipage@wd{100*}%
	\def\cpge@tmpl{#1}%
	\def\cpge@tmpr{#2}%
	\ifblank{#3}{}{\eqn@shift{l}{#3}}
	\ifblank{#4}{}{\eqn@shift{r}{#4}}
	\def\cpge@tmplb{#8}%
	\ifstrequal{#5}{@}
		{}
		{%
			\ifblank{#5}
				{\let\eqnframecmd\deco@formula}
				{%
					\ifcsundef{deco@#5}
						{\cpgeframe@err{#5}}
						{\letcs\eqnframecmd{deco@#5}}%
				}%
		}%
	\ifis@result%
		\textmodetrue%
		\let\eqnframecmd\deco@result%
	\fi%
	\iftextmode
		\ifblank{#7}{}{\def\minipage@wd{#7}}%
	\fi%
	\ifstrequal{#6}{@}
		{\let\@ligned\relax}
		{%
			\ifblank{#6}
				{\def\@ligned{\aligned[t]}}
				{\def\@ligned{\aligned[#6]}}%
		}%
	\ifblank{#9}{}{\setlength\bigcenterskip{\bigcenterskip*\real{#9}}}
	\xmath@process
}
\long\def\xmath@process#1\end@xmath{%
	\ifx\relax\@ligned%
		\iftextmode%
			\long\def\cpge@tmpm{#1}%
		\else
			\def\cpge@tmpm{$\m@th\displaystyle#1$}%
		\fi%
	\else 
		\def\cpge@tmpm{$\m@th\displaystyle\@ligned#1\endaligned$}%
	\fi%
	\@xp\@center@\@xp
		{\minipage@wd}
		{\cpge@tmpl}
		{\cpge@tmpm}
		{\cpge@tmpr}
		{\cpge@tmplb}%
}
\def\set@xmatherror{%
	\let\xmath@orig\<%
	\long\def\<{%
		\ifmmode
			\cpgemath@err
				{Commandes \string\< imbriquées}
				{deux séquences \string\< ...\string \> 
					ne peuvent être imbriquées ^^Jsauf si
					la première utilise le modificateur \r 
				}
		\else
			\@xp\xmath@orig
		\fi
	}
}
\NewDocumentEnvironment{xmath}{ t\a +b}
	{%
		\set@xmatherror%
		\xmath@init#2\end@xmath%
	}{}

\NewDocumentCommand\xmath@single{+r\<\>}
	{\begin{xmath}#1\end{xmath}}
\long\def\<{\xmath@single\<}


%%%%% Interfaces utilisateur pour \@center@ et \begin@center@

%%%% Parsing d'une ligne dans une suite d'équations dans xdevel ou xalign
\def\eqline@parser@err#1{%
	\cpgemath@err{\string #1\space  n'a pas sa place 
	dans l'argument de \@xp\noexpand
	\csname eqnline@\romannumeral \eqn@count@ @\endcsname
	}{
	équilibrez la ligne \the\eqn@count@\space en plaçant correctement 
	\string\<, \string\>\space et \string\eline}
}
\def\eqline@oneline@err{%
	\cpgemath@err{\@xp\string\@currenvir\space 
	traite une seule ligne
	}{utilisez xdevel ou xalign pour traiter plusieurs lignes}
}
\def\set@eqnerrors{%
	\let\eqline\relax%
	\def\<{\eqline@parser@err\<}%
	\def\>{\eqline@parser@err\>}%
	\def\eline{\eqline@parser@err\eline}%
}
\NewDocumentCommand\eqn@graber{+u\eline}{
	\lr@textgraber#1\"\"\grab@nil
}
\long\def\lr@textgraber#1\"#2\"#3\grab@nil{%
	\ifblank{#2}
		{\textmodefalse\lr@graber#1\grab@nil}
		{
			\textmodetrue%
			\eqn@graber@i@{#1}%
			\eqn@graber@ii@{#2}%
			\eqn@graber@iii@{#3}%
			\shipout@eqline%
		}%
}
\long\def\lr@graber#1\<#2\>#3\grab@nil{%
		\eqn@graber@i@{#1}%
		\eqn@graber@ii@{#2}%
		\eqn@graber@iii@{#3}%
		\shipout@eqline%
}

\def\endin@graber#1#2{%
	\endin@graber@#1\end{#2}\grab@nil%
}
\def\endin@graber@#1\end#2#3\grab@nil{%
	\ifdefstring{\@currenvir}{#2}
		{\cpgemath@err{\string\eline\space en dehors de #2.
		La compilation va probablement échouer}{}}%
}
\long\def\eqn@graber@i@#1{%
	\@bsphack
	\ifblank{#1}{\let\cpge@tmpx\@empty}
	{\edef\cpge@tmpx{%
		\unexpanded{\def\eqn@num@{i}}%
		\expandonce\eqn@ltextfunc{%
			\unexpanded{\xtrimspaces{#1}}%
		}%
	}}%
	\@esphack
}
\def\eqn@graber@ii@#1{%
	\ifblank{#1}{\global\let\cpge@tmpy\@empty}
	{\fake@eqn@mtextfunc{#1\math@nil}%
		\xdef\cpge@tmpy{%
		\unexpanded{\def\eqn@num@{ii}}%
		\expandonce\eqn@mtextfunc
			\unexpanded{#1\math@nil}%
	}}%
}
\def\eqn@graber@iii@#1{%
	\@bsphack
	\ifblank{#1}{\let\cpge@tmpz\@empty}
	{\edef\cpge@tmpz{%
		\unexpanded{\def\eqn@num@{iii}}%
		\expandonce\eqn@rtextfunc{%
			\unexpanded{\xtrimspaces{#1}}%
		}%
	}}%
}
\def\shipout@eqline{%\show\cpge@tmpz
	\edef\cpge@tmpe{%
		\expandonce\eqn@exec
			{\expandonce\cpge@tmpx}
			{\expandonce\cpge@tmpy}
			{\expandonce\cpge@tmpz}%
	}%
	\@esphack%
	%\show\cpge@tmpe
	\cpge@tmpe%
	\eqn@finalizer%
}
\def\renew@graber#1{%
	\advance\eqn@count\@ne
	\@xp\NewDocumentCommand
		\csname eqline@\romannumeral\eqn@count\endcsname
		{u\eline}
		{%
		   %\endin@graber{##1}{#1}%
		   \lr@graber##1\<\>\grab@nil%
		}%
	}
\def\eqn@initgrabers{%
	\global\advance\eqn@count@\@ne%
	\cslet{eqline@\romannumeral\eqn@count@ @i}\eqn@graber@i%
	\cslet{eqline@\romannumeral\eqn@count@ @ii}\eqn@graber@ii%
	\cslet{eqline@\romannumeral\eqn@count@ @iii}\eqn@graber@iii%
	\csname eqline@\romannumeral\eqn@count@ @i\endcsname%
	}
\def\eqn@initgrabers@{%
	\eqn@count@\@ne%
	\let\eqline@i@i\eqn@graber@i%
	\let\eqline@i@ii\eqn@graber@ii%
	\let\eqline@i@iii\eqn@graber@iii%
	\def\eqn@initgrabers{\eqline@oneline@err}%
	\eqline@i@i%
	}
\long\def\eqn@graber@i#1\<{%
	\@bsphack
	\edef\cpge@tmpx{%
		\unexpanded{\def\eqn@num@{i}}%
		\expandonce\eqn@ltextfunc{%
			\unexpanded{\xtrimspaces{#1}}%
		}%
	}%
	\@esphack
	%\show\cpge@tmpx%
	\csname eqline@\romannumeral\eqn@count@ @ii\endcsname%
}
\def\eqn@graber@ii#1\>{%
	\fake@eqn@mtextfunc#1\math@nil%sets \cpge@tmpx and \cpge@tmpz with the \lt and \rt flags 
	\xdef\cpge@tmpy{%
		\unexpanded{\def\eqn@num@{ii}}%
		\expandonce\eqn@mtextfunc
			\unexpanded{#1\math@nil}%
	}%
	%\show\cpge@tmpy
	\csname eqline@\romannumeral\eqn@count@ @iii\endcsname%
}
\def\eqn@graber@iii#1\eline{%
	\@bsphack
	\ifundef{\cpge@tmpz}{
	\edef\cpge@tmpz{%
		\unexpanded{\def\eqn@num@{iii}}%
		\expandonce\eqn@rtextfunc{%
			\unexpanded{\xtrimspaces{#1}}%
		}%
	}}{}%
	%\show\cpge@tmpz
	\edef\cpge@tmpe{%
		\expandonce\eqn@exec
			{\expandonce\cpge@tmpx}
			{\expandonce\cpge@tmpy}
			{\expandonce\cpge@tmpz}%
	}%
	\@esphack%
	%\show\cpge@tmpe
	\cpge@tmpe%
	\eqn@finalizer%
}
\NewDocumentCommand\eqn@finalizer{%
	s
	o
	t\eline 
	t\xxx@eline
	+e\end
}{
	\IfValueTF{#5}
		{\end{#5}}
		{%
			\IfBooleanF{#4}
				{%
					\IfBooleanT{#1}{\endpar}
					\IfValueT{#2}{\vskip#2}
					\eqn@initgrabers%
				}%
		}%
}
\let\l@qnshift\z@
\let\r@qnshift\z@
\cpgesetupmath{%
	left shift/.code	= \eqn@shift{l}{#1},
	right shift/.code	= \eqn@shift{r}{#1},
	rs/.style			= {right shift=#1},
	ls/.style			= {left shift=#1},
}
\def\eqn@shift#1#2{%
	\ifnumgreater{#2}{10}%
		{\csdef{#1@qnshift}{10}}%
		{\csdef{#1@qnshift}{#2}}%
}

\def\set@eqnparsers#1#2{%
	\def\do##1{%
		\ifcsdef{#1@##1}
			{\csedef{eqn@##1}{\@xp\@nx\csname#1@##1\endcsname}}
			{}%
	}%
	\def\cpge@tmpe{#2}%
	\ifblank{#2}
		{%
			\def\cpge@tmpe{
				exec,
				ltextfunc,
				mtextfunc,
				rtextfunc,
				finalizer,
				shift} 
		}{}%
	\@xp\docsvlist\@xp{\cpge@tmpe}%
}

%%% generic commands
\long\def\eqn@exec#1#2#3{#1$#2$#3}
\long\def\eqn@ltextfunc{\fake@cmd}
\long\def\eqn@rtextfunc{\fake@cmd}
\NewDocumentCommand\fake@eqn@mtextfunc{
	t\n
	t\r
	E{\fr\lb\al\wd\lt\rt}{{@}{}{@}{@}{}{}}
	u\math@nil
}{
	\undef\cpge@tmpz%
	\ifblank{#7}{}
		{%
			\edef\cpge@tmpx{%
				\unexpanded{\def\eqn@num@{i}}%
				\expandonce\eqn@ltextfunc{%
					\unexpanded{\xtrimspaces{#7}}%
				}%
			}%
		}%
	\ifblank{#8}{}
		{%\def\eqn@num@{iii}
			\edef\cpge@tmpz{%
				\unexpanded{\def\eqn@num@{iii}}%
				\expandonce\eqn@rtextfunc{%
					\unexpanded{\xtrimspaces{#8}}%
				}%
		}}%
}
\NewDocumentCommand\eqn@mtextfunc{
	t\n
	t\r
	E{\fr\lb\al\wd\lt\rt}{{@}{}{@}{@}{}{}}
	u\math@nil
}{
	\let\eqnframecmd\eqn@fakecmd%
	\def\minipage@wd{100*}%
	\IfBooleanTF{#1}
		{\global\eqn@numbertrue}
		{\global\eqn@numberfalse}%
	\IfBooleanTF{#2}
		{\textmodetrue%
			 \let\eqnframecmd\deco@result}
		{\textmodefalse}%
	\ifstrequal{#3}{@}
		{}
		{%
			\ifblank{#3}
				{\IfBooleanF{#2}{\let\eqnframecmd\deco@formula}}
				{%
					\ifcsundef{deco@#3}
						{\cpgeframe@err{#3}}
						{\letcs\eqnframecmd{deco@#3}}%
				}%
		}%
	\gdef\cpge@tmpl{#4}%
	\ifstrequal{#6}{@}{}
		{%
			\textmodetrue%
			\ifblank{#6}{}{\def\minipage@wd{#6}}
		}%
	\iftextmode%
		\@xp\eqn@preparemidbox\@xp{\minipage@wd}{%
			\ifstrequal{#5}{@}
				{#9}
				{%
					\ifblank{#5}
						{$\aligned[t]#9\endaligned$}
						{$\aligned[#5]#9\endaligned$}
				}
		}%%
		\def\cpge@tmpm{%
			\eqnframecmd{$\m@th
			\vcenter{%
				\hsize\midwidth\@parboxrestore\box\midbox%
			}$}%
		}%
		\textmodefalse%
	\else
		\def\cpge@tmpm{%
			\eqnframecmd{$\m@th\displaystyle
				\ifstrequal{#5}{@}{}
					{\ifblank{#5}{\aligned[t]}{\aligned[#5]}}
				#9
				\ifstrequal{#5}{@}{}{\endaligned}
			$}%
		}%
	\fi%
	\cpge@tmpm%
	\textmodefalse%
	\undef{\eqnframecmd}
}

%%% Goodies
\newif\ifeqn@break

\NewDocumentCommand\xbreak{O{t} m}{%
	\global\eqn@breaktrue
	\begin{multlined}[#1]
		#2
	\end{multlined}
}
\NewDocumentCommand\compactbreak{O{t} m}{%
	\global\eqn@breaktrue
	\ifcompact
		\begin{multlined}[#1]
			#2
		\end{multlined}
	\else
		#2
	\fi
}
\NewDocumentCommand\xaligned{O{t} m}{%
	\begin{aligned}[#1]
		#2
	\end{aligned}
}
\NewDocumentCommand\xsplit{O{t} m}{%
	\begin{split}[#1]
		#2
	\end{split}
}
\NewDocumentCommand\compactsplit{O{t} m}{%
	\ifcompact
		\begin{split}[#1]
			#2
		\end{split}
	\else
		#2
	\fi
}
%% Pour maintenir une compatibilité visuelle lorsque des \cas figurent
%% dans un environnement {xalign} ou {xdevel} de cpgemath.sty
\NewDocumentCommand\math@unit{ s O{} }{%
	\ifdim\leftmargin=\z@
		\leftmargin=\leftmargini
	\fi
	\IfBooleanTF{#1}
		{%
			\parshape=1 \leftmargin \dimexpr\linewidth-\leftmargin\relax%
			\ignorespaces
		}
		{%
			\parshape=2	\z@				\linewidth
						\leftmargin		\dimexpr\linewidth-\leftmargin\relax%
			\noindent\deco@unit{#2}\enskip\ignorespaces
		} 
}
\def\set@goodies{%
	\@bsphack
		\def\unit{\math@unit}
		\def\xbrk{\xbreak}%
		\def\xald{\xaligned}%
		\def\xspl{\xsplit}%
		\def\xvar{\intvar}%
		\def\xsavedff{\saved@@@@}%
		\def\sff{\saved@@@@}%
	\@esphack%
}

%%%%%%%% Alignement À la AMSmath
\newdimen\largetextabove \largetextabove=3\p@
\newdimen\largetextbelow \largetextbelow=\z@
\newbox\cpgetag@box
\newdimen\cpgetag@width

\def\tag@kern{\kern\eqn@tagkern}
\cpgesetdeco{tag}{(\hskip1\p@#1\hskip1\p@)}
\newtagform{cpge}[\deco@tag]{}{}
\DeclareListParser\doorloop\or
\DeclareListParser*\fororloop\or

\cpgesetupmath[math]{%
	big space/.code 		= \bigcenterskip\glueexpr#1\relax,
	med space/.code			= \medcenterskip\glueexpr#1\relax,
	small space/.code		= \smallcenterskip\glueexpr#1\relax,
	large text above/.code 	= \largetextabove=#1,
	large text below/.code 	= \largetextbelow=#1,
	tag sep/.code 			= \dimdef{\eqn@tagkern}{#1},
	tag sep					= .5em,
	allow break/.code 		= \allowsdsiplaybreak,
	} 
	
%%%% \largetext,  variant of mathools's \shortintertext
\def\largetext#1{%
	\ifvmode\else
		\crcr
	\fi
	\noalign{%
		\vskip-\ht\strutbox
		\vskip-\dp\strutbox
		\vskip-\lineskiplimit
		\unless\ifnum\row@=\z@\relax
			\penalty\postdisplaypenalty
			\vskip\abovedisplayshortskip
			\vskip\normallineskiplimit
			\vskip\largetextabove
		\fi%
		\vbox{%
			\normalbaselines
			\ifdim
				\ifdim
					\@totalleftmargin=\z@\linewidth
				\else
					-\maxdimen
				\fi
				=\columnwidth
			\else
				\parshape\@ne \@totalleftmargin \linewidth
			\fi
			\noindent\ignorespaces #1\par%
		}%
		\penalty\predisplaypenalty
		\vskip\abovedisplayshortskip
		\vskip-\lineskiplimit
		\vskip\normallineskiplimit
		\vskip\largetextbelow
	}%
}

%%%%%% Environnement xalign
%%%%%% generated lists by amsmath's mesuring
%% \field@lengths : 
%%		\or/csv list, \or seprating lines and comma the width of every 
%% 		field in the line. 
%%			Queue order
%% 			\fieldlengths@ for the extraction of a line
%% \tag@lengths : 
%%		\or list with the width of the tags on every line.
%% 			Queue order
%% 			\tag@width for the extraction
%% \tag@shifts : 
%%		\or list of 0 and 1, 1 indicating à tag shift of the 
%% 		corresponding line. 
%%			Stack order. 
%% 			\shift@tag for the extraction
%% \maxcolumn@widths : 
%%		\or list of the max width on every column. 
%%			Stack order
%% 			\maxcol@width for the extraction



%%%%% Macros pour le traitement des données générées par 
%%%%% la phase measuring d'amsmath
\let\tag@presence\@empty	% \or list of 0 and 1 indicating lines with tag
\let\lastfields@\@empty		% \or list of the indices of the last non empty columns
\let\firstfields@\@empty	% same thing for the first non empty fields
\let\ltext@widths\@empty	% \or list of the left text widths
\let\rtext@widths\@empty	% \or list of the text text widths	
\let\left@shifts\@empty		% \or list of 0 and 1 indicating shifts for the left 
							% text. there's no \right@shifts, amsmath's native 
							% \tag@shifts is used instead 

\def\save@entry#1#2{%
    \begingroup
        \let\or\relax
        \xdef#2{#2\or #1}%
    \endgroup
}
\def\save@csentry#1#2{%
    \begingroup
        \let\or\relax
        \csxdef{#2}{\csname#2\endcsname \or #1}%
    \endgroup
}
\def\get@entry#1#2{%
	\ifcase\@xp#1#2\fi
}
\def\text@mesuring#1#2{
	\begingroup
		\settowidth\cpge@dima{#2}
		\save@csentry{\the\cpge@dima}{#1@widths}
	\endgroup
}
\def\get@fieldwidth#1#2#3{
	\begingroup
	\cpge@loop\z@
	\edef\cpge@tmpb{\fieldlengths@#1}%
	\@for\cpge@tmpa:=\cpge@tmpb\do{%
            \advance\cpge@loop\@ne
            \ifnum\cpge@loop=#2\relax
            	\edef\cpge@tmpc{\cpge@tmpa}
			\fi
	}
	\xdef#3{\cpge@tmpc}
	\endgroup
}
\def\save@firstlastfields{
	\begingroup
	\def\do@row##1{	
		\column@\z@
		\docsvlist{##1}
		\ifundef\cpge@tmpfirst
			{
				\save@entry0\firstfields@
				\save@entry0\lastfields@
			}{
				\save@entry\cpge@tmpfirst\firstfields@
				\save@entry\cpge@tmplast\lastfields@
			}
		\undef\cpge@tmpfirst
	}
	\def\do##1{%
		\advance\column@\@ne
		\ifdim##1>\z@\relax
			\ifundef\cpge@tmpfirst{\edef\cpge@tmpfirst{\the\column@}}{}
			\edef\cpge@tmplast{\the\column@}
		\fi
	}
	\@xp\fororloop\@xp\do@row\@xp{\field@lengths}
	\endgroup
}
\def\find@maxtagwidth#1{%
	\begingroup
		\settowidth\cpge@dima{\tag@kern\deco@tag{#1}}
		\ifdim\cpge@dima>\cpgetag@width
			\global\cpgetag@width\cpge@dima
		\fi
		\setbox\z@\hbox{\tag@kern\deco@tag{}}
		\ifdim\cpge@dima>\wd\z@
			\save@entry1\tag@presence
		\else
			\save@entry0\tag@presence
		\fi
	\endgroup
}
\def\tag@measuring#1{%
	\ifeqn@number
		\stepcounter{equation}%
		\find@maxtagwidth{\theequation}
	\else
		\find@maxtagwidth{#1}
	\fi
}
\def\set@tag#1{%
	\ifeqn@number
		\refstepcounter{equation}%
		\setbox\cpgem@boxa\hbox{%
			\tag@kern\deco@tag{\theequation}%
		}
		\ifblank{#1}{}{\label{#1}}
	\else
		\ifblank{#1}
			{\setbox\cpgem@boxa\hbox{}}
			{%
				\setbox\cpgem@boxa\hbox{%
					\tag@kern\deco@tag{#1}
				}
			}
	\fi
	\ifdim\wd\cpgem@boxa>\z@
		\global\setbox\cpgem@boxa\hb@xt@\cpgetag@width{%
			\hss\unhbox\cpgem@boxa
		}
	\fi
}
%%%% Main macro. Prepare the shift tables for left and right text 
%%%% after amsmath's measuring is done.
\def\after@measuring{\begingroup
	\numdef\rows@number{\row@}
	\save@firstlastfields
	\row@\z@
	\column@\z@	
	\let\left@shifts\@empty
	\let\tag@shifts\@empty
	\whileboolexpr{ test {\ifnumless\row@\rows@number} }
		{
			\advance\row@\@ne
			\edef\cpge@tmpf{\get@entry\row@\firstfields@}
			\get@fieldwidth\row@\cpge@tmpf\cpge@tmpd
			\cpge@dimb=\dimexpr-\mintagsep-\cpge@tmpd\relax
			\column@\z@
			\whileboolexpr{ test {\ifnumless\column@{\cpge@tmpf}} }
				{
					\advance\column@\@ne
					\advance\cpge@dimb\maxcol@width\column@\relax
					\unless\ifodd\column@
						\advance\cpge@dimb\alignsep@
					\fi
				}
			\cpge@dimc\get@entry\row@\ltext@widths\relax
			\ifdim\cpge@dimb<\cpge@dimc
				\save@entry1\left@shifts
			\else
				\save@entry0\left@shifts
			\fi
		}
	\row@\z@	\column@\z@
	\whileboolexpr{ test {\ifnumless\row@\rows@number} }
		{
			\advance\row@\@ne
			\column@\get@entry\row@\lastfields@\relax
			\get@fieldwidth\row@\column@\cpge@tmpd
			\cpge@dimb=-\cpge@tmpd
			\whileboolexpr{ test {\ifnumless\column@{\maxfields@+1}} }
				{
					\advance\cpge@dimb\maxcol@width\column@\relax
					\unless\ifodd\column@
						\advance\cpge@dimb\alignsep@
					\fi
					\advance\column@\@ne
				}
			\advance\cpge@dimb-\alignsep@\relax
			\advance\cpge@dimb-\mintagsep\relax
			\cpge@dimc\get@entry\row@\rtext@widths\relax
			\if1\get@entry\row@\tag@presence\relax
				\advance\cpge@dimc\cpgetag@width
			\fi
			\ifdim\cpge@dimc<\cpge@dimb
				\save@entry0\tag@shifts
			\else
				\save@entry1\tag@shifts
			\fi
		}
	\global\let\ltext@widths\@empty
	\global\let\rtext@widths\@empty
	\global\let\firstfields@\@empty
	\global\let\lastfields@\@empty
	\global\let\tag@presence\@empty
\endgroup}

\long\def\start@xalign#1#2{%
    \let\xatlevel@\tw@
    \maxfields@\m@ne\relax
    \ifingather@
        \iffalse{\fi\ifnum0=`}\fi
        \DN@{\vcenter\bgroup\savealignstate@\xalign@}%
    \else
        \ifmmode
          \if@display
             \DN@{\align@recover}%
          \else
            \nomath@env
            \DN@{\@namedef{end\cpge@currenvir}{}\@gobble}%
          \fi
        \else
            $$%
            \let\split\insplit@
            \DN@{\xalign@{#1}{#2}}%
        \fi
    \fi
    \collect@body\next@
}
\iffalse $$\fi% Hack benin pour interrompre la coloration syntaxique causée par $$ dans l'éditeur . 
\def\xalign@#1#2#3{%
	\inalign@true
	\cpge@indisplaytrue
	\chardef\dspbrk@context\z@
	\ifingather@\else\displ@y@\fi
	\let\math@cr@@@\math@cr@@@align
	\let\tag\tag@in@align
	\let\invalid@tag\xalign@tag@err
	\let\label\label@in@display
	\st@rredtrue% set st@r
	\def\xalign@BODY{#3}
	\preto\xalign@BODY{#1}
	\appto\xalign@BODY{#2}
%	\show\xalign@BODY
	\xalign@BODY
	\@xp\def\@xp\xalign@BODY\@xp{\cpge@tmpw}
%	\show\xalign@BODY
	\measure@{\xalign@BODY}%
	\after@measuring
	\global\row@\z@
	\tabskip\eqnshift@
	\halign\bgroup
		\span\align@preamble\crcr
		\xalign@BODY%
}
%%%
\NewDocumentCommand\xalign@finalizer{%
	s
	o
	t\eline 
	t\xxx@eline
	+e\end
}{
	\IfValueTF{#5}
		{\end{#5}}
		{%
			\IfBooleanF{#4}
				{%
					\IfBooleanTF{#1}
						{\IfValueTF{#2}
							{\appto\cpge@tmpw{\math@cr*[#2]}}
							{\appto\cpge@tmpw{\math@cr*}}
						}
						{\IfValueTF{#2}
							{\appto\cpge@tmpw{\math@cr[#2]}}
							{\appto\cpge@tmpw{\math@cr}}
						}
					\eqn@initgrabers%
				}%
		}%
}
%%%%
\long\def\xalign@ltextfunc#1{%
	\cpge@indisplayfalse
	\ifmeasuring@ 
		\hbox{}
		\text@mesuring{ltext}{#1}
	\else
		\advance\row@\@ne
		\if0\get@entry\row@\left@shifts\relax
			\rlap{#1}
		\else
			\largetext{#1}
		\fi
	\fi
}
\def\xalign@rtextfunc#1{%
	\cpge@indisplayfalse
	\ifmeasuring@
		\hbox{}
		\tag@measuring{\cpge@tmpl}
		\text@mesuring{rtext}{#1}
		\tag@in@align*{}
	\else
		\@xp\set@tag\@xp{\cpge@tmpl}
		\global\shifttag@true
		\raisetag{-\numvskip}
		\tag@in@align*{#1\box\cpgem@boxa}
	\fi
}
\NewDocumentCommand\get@firstfield{ u& u\cpge@nil }{#1}
\NewDocumentCommand\xalign@mtextfunc{
	t\n
	E{\fr\lb\lt\rt\al}{{@}{}{}{}{}}
	u\math@nil
}{%
	\IfBooleanTF{#1}
		{\global\eqn@numbertrue}
		{\global\eqn@numberfalse}
	\ifstrequal{#2}{@}{}
		{%
			\ifblank{#2}
				{\gdef\eqn@framecmd{\Xboxed[formula]}}
				{\gdef\eqn@framecmd{\Xboxed[#2]}}
		}
	\ifundef\saved@@@@
		{\gdef\saved@@@@{\get@firstfield#7&\cpge@nil}}
		{}
	\gdef\cpge@tmpl{#3}
	\eqn@framecmd{#7}
	\global\let\eqn@framecmd\eqn@fakecmd
}
\let\eqn@framecmd\eqn@fakecmd
\def\xalign@exec#1#2#3{%
	\appto\cpge@tmpw{#1 \l@mpshift #2 \r@mpshift #3}
}
%%% 
\def\xalign@shift#1#2{
	\ifcase\numexpr#2\relax
		  \or \csdef{#1@mpshift}{&&&&&&}
		   \or \csdef{#1@mpshift}{&&&&&&&&}
		    \or \csdef{#1@mpshift}{&&&&&&&&&&}
		     \or \csdef{#1@mpshift}{&&&&&&&&&&&&}
		      \or \csdef{#1@mpshift}{&&&&&&&&&&&&&&}
		       \or \csdef{#1@mpshift}{&&&&&&&&&&&&&&&&}
		        \or \csdef{#1@mpshift}{&&&&&&&&&&&&&&&&&&}
		         \or \csdef{#1@mpshift}{&&&&&&&&&&&&&&&&&&&&}
		          \or \csdef{#1@mpshift}{&&&&&&&&&&&&&&&&&&&&&&}
		           \or \csdef{#1@mpshift}{&&&&&&&&&&&&&&&&&&&&&&&&}
	\fi
}
\def\l@mpshift{&&&&}
\def\r@mpshift{&&&&}
\def\set@eqnskips{%
	\@bsphack
		\abovedisplayskip\bigcenterskip\relax%
		\belowdisplayskip\bigcenterskip\relax%
		\abovedisplayshortskip\medcenterskip\relax%
		\belowdisplayshortskip\medcenterskip\relax%
	\@esphack%
}
\NewDocumentEnvironment{xalign}{O{}}{%
	\cpgetag@width\z@%
	\eqn@count@\z@%
	\let\cpge@tmpw\@empty%
	\def\cpge@currenvir{xalign}%
	\allowdisplaybreaks%
	\set@eqnskips%
	\set@goodies%
	\set@eqnparsers{xalign}{}%
	\set@eqnerrors%
	\cpgesetupmath{#1}%
	\start@xalign{\eqn@initgrabers}{\eline\xxx@eline}
}{%
	\unset@goodies%
	\endalign%
}
\def\unset@goodies{%
	\@bsphack%
		\global\let\eqnframecmd\eqn@fakecmd%
		\gundef\saved@@@@%
	\@esphack%
}
% % patch for the usual alignement env of AMSmath to support the \< \> syntax
% \NewDocumentCommand\cpge@eline{
% 	s
% 	O{\z@}
% 	t\eline
% 	e\end
% }{
% 	\IfValueTF{#4}
% 		{\end{#4}}
% 		{
% 			\IfBooleanTF{#1}
% 				{\math@cr*[#2]}
% 				{\math@cr[#2]}
% 		}
% }
% \NewDocumentCommand\cpge@bline{
% 	 t{\n}
% 	 E{\fr\lb}{{@}{}}
% 	 u{\>}
% }{%
% 	\IfBooleanTF{#1}
% 		{\eqn@number{#3}}
% 		{\cpge@nonumber{#3}}
% 	\ifstrequal{#2}{@}
% 		{\global\let\eqn@framecmd\eqn@fakecmd}	
% 		{%
% 			\ifblank{#2}
% 				{\gdef\eqn@framecmd{\Xboxed[formula]}}
% 				{\gdef\eqn@framecmd{\Xboxed[#2]}}
% 		}
% 	\ifundef\saved@@@@
% 		{\gdef\saved@@@@{\get@firstfield#4&\cpge@nil}}
% 		{}
% 	\eqn@framecmd{#4}
% }
% \def\eqn@number#1{%
% 	\ifst@rred
% 		\st@rredfalse\global\@eqnswtrue
% 		\ifblank{#1}{}{\label{#1}}
% 	\else
% 		\ifblank{#1}{}{\label{#1}}
% 	\fi
% }
% \def\cpge@nonumber#1{%
% 	\ifst@rred
% 		\ifblank{#1}{}{\tag*{\deco@tag{#1}}}
% 	\else
% 		\ifblank{#1}{\nonumber}{\tag*{\deco@tag{#1}}}
% 	\fi
% }	
% \def\Let@ig{%
% 	\let\cpge@currenvir\@currenvir%
% 	\set@eqnskips%
% 	\set@goodies
% 	\def\eline{\cpge@eline}%
% 	\def\<{\cpge@bline}%
% 	\let\eqnline\@empty%
% 	\def\xsavedff{\saved@@@@}%
% 	\def\sff{\saved@@@@}%
% 	\cpge@indisplaytrue%
% 	\ignorespaces
% }
%%% Tag's style and patching
\def\tagform@err{%
	\cpgemath@err{%
		\string\usetagform\space n'est pas disponible
		\MessageBreak utilisez \string\cpgesetdeco\string{tag\string}
		pour modifier le style des tags.
	}{Voir le manuel}
}
\AtBeginDocument{%
	%\preto\align{\Let@ig}%
	%\preto\flalign{\Let@ig}%
	%\preto\aligned{\Let@ig}%
	%\preto\equation{\Let@ig}%
	%\cspreto{align*}{\Let@ig}%
	%\cspreto{flalign*}{\Let@ig}%
	%\cspreto{equation*}{\Let@ig}%
	%\appto\endalign{\unset@goodies}
    \usetagform{cpge}
    \makeatletter
    	\def\usetagform{\tagform@err}
	\makeatother
}

%%%% 
%% \xboxed normale

\NewDocumentCommand\MakeXboxedCommand{mm}{
	\newcommand#1[1]{%
		\let\bgroup{\romannumeral-`}%
		\csuse{xbxd\@xp\@gobble\string#1}##1&&\cpge@nil
	}
	\csdef{xbxd\@xp\@gobble\string#1}##1&##2&##3\cpge@nil{%
		\settowidth\cpge@dimc{#2{}}%
		\ifnum0=`{}\fi%
		\setbox\z@\hbox{#2{$\displaystyle##1{}\m@th$\kern-.5\cpge@dimc}}%
		\edef\cpge@tmpa{%
			\kern\wd\z@&\kern-\the\wd\z@%
		}%
		\ifblank{##1##2}{}
			{%
				\cpge@tmpa%
				#2{\m@th$\displaystyle ##1##2$}%
			}%
  }
}	
\MakeXboxedCommand\xboxed\deco@formula
\MakeXboxedCommand\xdeco@formula\deco@formula
\MakeXboxedCommand\xdeco@result\deco@result
\def\xdeco@r{\xdeco@result}

%%%% \Xboxed, version récursive de \xboxed
\NewDocumentCommand\Xboxed
{
	O{formula} >{\SplitList{&}} m
}{
	\ifcsundef{xdeco@#1}
		{\cpgeframe@err{#1}}
		{\gdef\eqnframecmd{\csname xdeco@#1\endcsname}}
	\xboxed@rec@#2@@\frame@nil%
}
\def\xboxed@rec@#1#2#3\frame@nil{%
	\gdef\@tmpa{#3}%
	\ifstrequal{#1}{@}{}
	{
		\ifstrequal{#2}{@}
			{\eqnframecmd{#1}}
			{%
				\eqnframecmd{#1&#2}%
				\@xp\@ifnc@t\@tmpa\frame@nil%
			}%
	}%
}
\def\@ifnc@t#1#2\frame@nil{%
	\ifstrequal{#1}{@}{}{&\@xp\xboxed@rec@#1#2\frame@nil}%
}			

%%% AMSmath end %%%%%%%

%%%%%%%% Environnements basique pour théorèmes et Cie
%%%%%%%% 
    \theoremstyle{plain}
    \newtheorem{theo}{Th\'eor\`eme}
    \newtheorem{theodef}{Th\'eor\`eme et d\'efinition}
    \newtheorem{ppte}{Propri\'et\'es}
    \newtheorem{prop}{Proposition}
	\newtheorem{lemm}{Lemme}
    \newtheorem*{theo*}{Th\'eor\`eme}
    \newtheorem*{theodef*}{Th\'eor\`eme et d\'efinition}
    \newtheorem*{ppte*}{Propri\'et\'es}
    \newtheorem*{prop*}{Proposition}
	\newtheorem*{lemm*}{Lemme}
    \theoremstyle{definition}
    \newtheorem{defi}{D\'efinition}
    \newtheorem*{defi*}{D\'efinition}
	\newtheorem{voca}{Vocabulaire}
    \newtheorem*{voca*}{Vocabulaire}
	\theoremstyle{remark}
	\newtheorem{rema}{Remarque}
	\newtheorem*{rema*}{Remarque}
%%%% Frame générique pour théorème et similaire
\newdimen\xframe@gap
\xframe@gap=\dimexpr2\fboxrule+2\fboxsep\relax
\NewDocumentEnvironment{xframe}{m d() d<> +b}
		{\deco@xframe{\parbox{\linewidth-\xframe@gap}{
			\IfValueTF{#2}
				{\IfValueTF{#3}{\begin{#1}[#2]\label{#3}}{\begin{#1}[#2]}}
				{\IfValueTF{#3}{\begin{#1}\label{#3}}{\begin{#1}}}
			#4
			\end{#1}}
		}}
		{}
\cpgesetdeco{xframe}{\fbox{#1}}
    
%%% Quantificateurs 
\cpgesetupmath{%
	forall sep/.code 2 args	= \def\forall@sep{#1}\def\forall@dsep{#2},
	exists sep/.code 2 args	= \def\exists@sep{#1}\def\exists@dsep{#2},
	forall sep				= {,\ }{\quad},
	exists sep				= {\ ;\ }{\enskip;\enskip},
}

\NewDocumentCommand\xforall{
	s
	t\M
	t\p
	u{\;} 
}{%
	\mathchoice 
		{\forall #4 \forall@dsep}
		{
			\IfBooleanTF{#1}
				{\forall #4 \forall@sep}
				{
					\text{%
						\IfBooleanTF{#2}{Pour tou}{pour tou}%
			 			\IfBooleanTF{#3}{s\ }{t\ }%
					}
					#4 \text{,\ }
				}
		}{\text{\text{Hoho ! c'est trop sérré ici}}}{}
}
\NewDocumentCommand\xexists{%
	s
	t!
	t\M
	t\f
	u{\;}
	%E{\tq}{{ tel que }}
}{%
	\mathchoice
		{\exists \IfBooleanT{#2}{!} #5 \exists@dsep}
		{\IfBooleanTF{#1}
			{\exists \IfBooleanT{#2}{!} #5 \exists@sep}
			{
				\text{\IfBooleanTF{#3}{I}{i}l existe\ }
				#5 \IfBooleanT{#2}{\text{ unique }} \text{ tel\IfBooleanT{#4}{le} que\ }
			}
		}{\text{Hoho ! c'est trop sérré ici}}{}
}


%%% Fractions
%%% originated from nicefrac.sty
%%% tribute to  Axel Reichert

\cpgesetupmath[fractions]{%
	delimiter/.code 	= \def\xfrac@dlm{#1},
	d/.style			= {delimiter = #1},
	d/.default			=\prt,
}
\def\cpgemathset@frac{\cpgesetupmath[fractions]}
\newlength{\cpge@RaiseD}
\newlength{\cpge@RaiseT}
\newlength{\cpge@RaiseS}

\def\cst@D{\displaystyle\def\cst@D{\cst@T}}
\def\cst@T{\textstyle\def\cst@T{\cst@S}}
\def\cst@S{\scriptstyle\def\cst@S{\cst@SS}}
\def\cst@SS{\scriptscriptstyle}
\def\just@netoken#1{\just@netoken@#1&\cpge@nil}
\def\just@netoken@#1#2\cpge@nil{%
	\ifstrequal{#2}{&}
		{\def\xfrac@dlm##1{##1}}
		{}
}
\def\xfrac@slash{\mkern-1mu/\mkern-1mu}
\newcommand\xfrac@[3][]{%
	%\delimiterfactor701%\relax\delimitershortfall2pt\relax
	\cpgemathset@frac{#1}
	\settoheight{\cpge@RaiseD}
		{\ensuremath{\displaystyle M}}%
	\settoheight{\cpge@RaiseT}
		{\ensuremath{\textstyle M}}%
	\settoheight{\cpge@RaiseS}
		{\ensuremath{\scriptstyle M}}%
	\settoheight{\@tempdima}
		{\ensuremath{\scriptscriptstyle M}}%
	\addtolength{\cpge@RaiseD}
		{-\cpge@RaiseS}%
	\addtolength{\cpge@RaiseT}
		{-\cpge@RaiseS}%
	\addtolength{\cpge@RaiseS}
		{-\@tempdima}%
	\mathchoice
		{\frac{#2}{#3}}%
		{\raisebox{\cpge@RaiseT}
			{%
				$\m@th\cst@T\just@netoken{#2}
				\xfrac@dlm{#2}\xfrac@slash$%
			}%
		}%
		{\raisebox{\cpge@RaiseS}
			{%
				$\m@th\cst@S\just@netoken{#2}
				\xfrac@dlm{#2}\xfrac@slash$%
			}%
		}%
		{\raisebox{\cpge@RaiseS}
			{%
				$\m@th\cst@SS\just@netoken{#2}
				\xfrac@dlm{#2}\xfrac@slash$%
			}%
		}%
	\bgroup
	\mathchoice
		{}%
		{\cst@T\just@netoken{#3}\cramped{\xfrac@dlm{#3}}}%
		{\cst@S\just@netoken{#3}\cramped{\xfrac@dlm{#3}}}%
		{\cst@SS\just@netoken{#3}\cramped{\xfrac@dlm{#3}}}%
	\egroup
}
\NewDocumentCommand\xfrac{s O{d}mm}{%
		\IfBooleanTF{#1}
			{\frac{#3}{#4}}
			{\xfrac@[#2]{#3}{#4}}
} 
    
%%%%%% Délimitateurs

%% Some ideas borrowed from mathtools and physics.sty

%%%for test needs, \prr defined a la mathtools 
%\AtBeginDocument{
	%\delimiterfactor850
	%\delimitershortfall-1sp
%}
\DeclarePairedDelimiter\prr()

%% Sub/Sup Stacking and Cramping

\def\mathnlap#1{#1}
\newenvironment{xsubarray}[1]{%
	\vcenter\bgroup
		\Let@ \restore@math@cr \default@tag
		\baselineskip\fontdimen10 
		\scriptfont\tw@
		\advance\baselineskip\fontdimen12 
		\scriptfont\tw@
		\lineskip\thr@@\fontdimen8 
		\scriptfont\thr@@
		\lineskiplimit\lineskip
		\ialign\bgroup\ifx c#1\hfil\fi
			$	
				\m@th\scriptstyle
				\kern-\nulldelimiterspace
				\radical\z@{##}
			$%
		\hfil\crcr
}{%
	\crcr\egroup\egroup
}
\newenvironment{xssubarray}[1]{%
  \vcenter\bgroup
		\Let@ \restore@math@cr \default@tag
		\baselineskip\fontdimen10 
		\scriptscriptfont\tw@
		\advance\baselineskip\fontdimen12 
		\scriptscriptfont\tw@
		\lineskip\thr@@\fontdimen8 
		\scriptscriptfont\thr@@
		\lineskiplimit\lineskip
		\ialign\bgroup\ifx c#1\hfil\fi
			$%	
				\m@th\scriptscriptstyle
				\kern-\nulldelimiterspace
				\radical\z@{##}
			$%
		\hfil\crcr
}{%
	\crcr\egroup\egroup
}
\newcommand{\xcsubstack}[2][]{
	\cpgesetupmath[supsub]{#1}
	\xsubarray{c}#2\endxsubarray
}
\newcommand{\xlsubstack}[2][]{
	\cpgesetupmath[supsub]{#1}
	\xsubarray{l}#2\endxsubarray
}
\let\xnsubstack\fake@cmd
\newcommand{\xscsubstack}[2][]{
	\cpgesetupmath[supsub]{#1}
	\xssubarray{c}#2\endxssubarray
}
\newcommand{\xslsubstack}[2][]{
	\cpgesetupmath[supsub]{#1}
	\xssubarray{l}#2\endxssubarray
}
\let\xsnsubstack\fake@cmd

\cpgesetupmath[supsub]{
	.unknown/.code=\relax,
	l/.code				= \def\lsp@s{l},
	c/.code				= \def\lsp@s{c},
	r/.code				= \def\lsp@s{r}, 
	position/.is choice,
	position/l/.style	= l,
	position/c/.style	= c,
	position/r/.style	= r,
	s/.code				= \let\ss@style\scriptstyle,
	ss/.code			= \let\ss@style\scriptscriptstyle,
	style/.is choice,
	style/s/.style		= s
	style/ss/.style		= ss,
	style/empty/.code	= \let\ss@style\@empty,
	style/empty,
	lap/.code			= \ifcsdef{math#1lap}
							{\letcs\ss@lap{math#1lap}}
						   	{\let\ss@lap\mathnlap},
	ll/.style			= {lap=l},
	cl/.style			= {lap=c},
	rl/.style			= {lap=r},
	nl/.style			= {lap=n},
	stack/.code			= \ifx\ss@style\scriptscriptstyle
							\ifcsdef{xs#1substack}
						  		{\letcs\ss@stack{xs#1substack}}
								{\let\ss@stack\xnsubstack}
						  \else
						   	\ifcsdef{x#1substack}
						  		{\letcs\ss@stack{x#1substack}}
								{\let\ss@stack\xnsubstack}  	
						 \fi,
	ls/.style			= {stack=l},
	cs/.style			= {stack=c},
	ns/.style			= {stack=n},
	smash/.code			= \def\ss@smashb{\smash[b]}
							\def\ss@smasht{\smash[t]},
	sm/.style			= smash,
	limits/.code		= \ifcsdef{#1limits}{\letcs\ss@limits{#1limits}}
						   {\let\ss@limits\@empty},
	lim/.style			={limits={}},
	nolim/.style		={limits=no},
	h/.code				= \def\cramp@h{#1mu},
	t/.code				= \def\cramp@t{#1ex/10},
	b/.code				= \def\cramp@b{#1ex/10},
	h/.default		=3,
	t/.default		=1,
	b/.default		=1,
	.save/.code			= \edef\h@backup{\cramp@h}
						  \edef\b@backup{\cramp@b}
						  \edef\t@backup{\cramp@t}
						  \let\last@stack\ss@stack
						  \let\last@lap\ss@lap,
	.restore/.code		= \edef\cramp@h{\h@backup}
						  \edef\cramp@b{\b@backup}
						  \edef\cramp@t{\t@backup}
						  \let\ss@style\@empty
						  \let\ss@stack\last@stack
						  \let\ss@lap\last@lap,
	noadjust/.style		= {h=0,t=0,b=0},
}
\cpgesetupmath[supsub]{%
	h=3,
	t=2.5,
	b=2.5,
	.save,
	lap=n,
	stack=n,
	limits={},
	style=empty
}
\let\ss@style\@empty
\let\ss@smasht\fake@cmd
\let\ss@smashb\fake@cmd

\NewDocumentCommand{\raisemath}{m}{\mathpalette{\raise@math{#1}}}
\def\raise@math#1#2#3{
	\let\cur@style#2
	\raisebox{#1}{%
		$\m@th\cur@style\ss@style{#3}$%
	}
}
\NewDocumentCommand\xsubsup{%
	o 
	E{_^}{{}{}}
}{%
	\IfValueT{#1}{\cpgesetupmath[supsub]{.save,#1}}%
	\ifblank{#2}{}
		{%
			_{{}\raisemath{\cramp@b}
				{\mkern-\cramp@h\ss@lap{\ss@smashb{\ss@stack{\ss@style#2}}}}
			}
		}%
	\ifblank{#3}{}
		{%
			^{{}\raisemath{-\cramp@t}
				{\mkern-\cramp@h\ss@lap{\ss@smasht{\ss@stack{\ss@style#3}}}}
			}
		}%
	\IfValueT{#1}{\cpgesetupmath[supsub]{.restore}}
}
\NewDocumentCommand\fake@subsup{%
	o 
	E{_^}{{}{}}
}{%
	\ifblank{#2}{}{_{#2}}
	\ifblank{#3}{}{^{#3}}
}
\def\x@subsup{\fake@subsup}
\def\xss{\xsubsup}

%%% Pushing

\NewDocumentCommand\xpush{ m }{%
	\begingroup
	\@ifisnumber{#1}
		{%
			\edef\@push{\endgroup%
				\noexpand\@xp\tmspace\temp@s{\temp@n mu}% 
					{\dimexpr\temp@n em/18}
			}
		}
		{\cpgesetupmath[pushing]{#1}}
	\@push%
}
\cpgesetupmath[pushing]{
	s/.code		= \def\@push{\endgroup\,},
	-s/.code	= \def\@push{\endgroup\!},
	m/.code		= \def\@push{\endgroup\:},
	-m/.code	= \def\@push{\endgroup\tmspace-\medmuskip{.2222em}},
	b/.code		= \def\@push{\endgroup\;},
	-b/.code	= \def\@push{\endgroup\tmspace-\thickmuskip{.2777em}},
	q/.code		= \def\@push{\endgroup\quad},
	-q/.code	= \def\@push{\endgroup\hskip-1em\relax},
	qq/.code	= \def\@push{\endgroup\qquad},
	-qq/.code	= \def\@push{\endgroup\hskip-2em\relax},
}
	
%% Préprocesseur des arguments
\newif\ifbr@@k
\def\set@dlmbig#1{%
	\ifcase#1   \set@dlmsize@
		   \or \set@dlmsize\big
	  		\or \set@dlmsize\Big
	    	 \or \set@dlmsize\bigg
	      	  \or \set@dlmsize\Bigg
	\else
		\set@dlmsize@lr
	\fi
}
\def\set@dlmoutbigggg#1{%
	\numdef\@tmpx{\dlm@count@}
	\ifnum\@tmpx<1
		\def\@tmpx{1}
	\else
		\aftergroup\dlm@aftergroup@
	\fi
	\ifnumgreater{#1}{4}{}{
	\xdef\cpge@tmpti{%
		\def\@xp\@nx\csname 
				dlm@\romannumeral\@tmpx @outsize%
			\endcsname{#1}
		\numdef\@xp\@nx\csname 
				dlm@\romannumeral\numexpr\@tmpx+1 @outsize%
			\endcsname{\ifnumgreater{#1}{1}{#1-1}{0}}
		\numdef\@xp\@nx\csname 
				dlm@\romannumeral\numexpr\@tmpx+2 @outsize%
			\endcsname{\ifnumgreater{#1}{2}{#1-2}{0}}
		\numdef\@xp\@nx\csname 
				dlm@\romannumeral\numexpr\@tmpx+3 @outsize%
			\endcsname{\ifnumgreater{#1}{3}{#1-3}{0}}
	}
	\cpge@tmpti
}}
\def\dlm@aftergroup@{\aftergroup\cpge@tmpti}
\cpgesetupmath{%
	max delim size/.code	= \set@dlmoutbigggg{#1},
	mds/.style				={max delim size=#1}
}
\def\dlm@i@outsize		{5}
\def\dlm@ii@outsize		{5}
\def\dlm@iii@outsize	{5}
\def\dlm@iv@outsize		{5}
\def\dlm@v@outsize		{5}
% \es :  espace 
% \sa :  la taille se propage à tous les délimiteurs de même niveau.
% \sz :  effet valable pour le délimiteur suivant
\NewDocumentCommand\dlm@PREPROCESS{
	s
	m
	t\l
	t\r
	E{\es\sa\sz\br}{{@}{@}{@}{@}}
}{%
	\advance\dlm@count@\@ne
	\IfBooleanF{#1}{%
		\def\dlmpr@c@{\dlmpr@c}%
		\IfBooleanT{#3}{\def\dlmpr@c@{\dlmpr@cl}}%
		\IfBooleanT{#4}{\def\dlmpr@c@{\dlmpr@cr}}%
	}
	\ifstrequal{#8}{@}
		{\br@@kfalse}
		{
			\br@@ktrue%
			\ifblank{#8}
				{\def\vert@br@@k{t}}
				{\def\vert@br@@k{#8}}%
		}%
	\ifstrequal{#5}{@}{}
		{\ifblank{#5}
			{\xpush{3}}
			{\xpush{#5}}%
		}%
	\begingroup%
	\@ifisnumber{#6}{\set@dlmoutbigggg{#6}}{}%
	\@ifisnumber{#7}
		{\set@dlmbig{#7}}
		{\set@dlmbig{\csuse{dlm@\romannumeral\dlm@count@ @outsize}}}%
	#2%
}

%%%%%%%%%%%% Les réglages essentiels sont là %%%%%%%%%%
\def\kill@mp#1{%
	\begingroup\catcode`\&=9\let\\\relax\scantokens{#1}\endgroup
}
\newcommand\ldelimsize[2][]{\relax}
\newcommand\rdelimsize[2][]{\relax}
\def\set@dlmsize#1{%
	\edef\@taille{\@xp\@gobble\string#1}
	\renewcommand\ldelimsize[2][]{%
		\ifstrequal{##2}{.}
		{\mathopen{}}
		{\mathopen{\@nameuse{\@taille l}##2}}
	}%
	\renewcommand\rdelimsize[2][]{%
		\ifstrequal{##2}{.}
		{\mathclose{}}
		{\mathclose{\@nameuse{\@taille r}##2}}
	}%
	\letcs\msize{mdelimesize@\@taille}%
	\def\tq{\given}
}
\def\set@dlmsize@lr{%
	\renewcommand\ldelimsize[2][]{%
		\ifbr@@k
			\mathopen{\mleft##2\vphantom{\kill@mp{##1}}\mright.}
		\else
			%\mathopen{}\mathclose\bgroup\left##2
			\mleft##2
		\fi
	}
	\renewcommand\rdelimsize[2][]{%
		\ifbr@@k
			\mathopen{\mleft.\vphantom{\kill@mp{##1}}\mright##2}
		\else
			%\aftergroup\egroup\right##2
			\mright##2
		\fi
	}
	\def\msize##1{%
		\mkern\GivSpace\middle##1
		\mkern\GivSpace\mathopen{}
	}
	\def\tq{\given}
}
\def\set@dlmsize@{%
	\renewcommand\ldelimsize[2][]{
		\ifstrequal{##2}{.}
			{\mathopen{}}
			{\mathopen{##2}}
	}% 
	\renewcommand\rdelimsize[2][]{
		\ifstrequal{##2}{.}
			{\mathclose{}}
			{\mathclose{##2}}
	}%
	\let\msize\relax
	\def\given{\:\GivenSep\:\mathopen{}}
	\let\tq\given
	}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\def\mdelimesize@#1{%
	\mkern\GivSpace
		#1
	\mkern\GivSpace\mathopen{}
}
\def\mdelimesize@big#1{%
	\mkern\GivSpace
		\big#1
	\mkern\GivSpace\mathopen{}
}
\def\mdelimesize@Big#1{%
	\mkern\GivSpace
		\Big#1
	\mkern\GivSpace\mathopen{}
}
\def\mdelimesize@bigg#1{%
	\mkern\GivSpace
		\bigg#1
	\mkern\GivSpace\mathopen{}
}
\def\mdelimesize@Bigg#1{%
	\mkern\GivSpace
		\Bigg#1
	\mkern\GivSpace\mathopen{}
}

\NewDocumentCommand\given{ m }{%
	\ifblank{#1}{\msize\GivenSep}
	{\ifcase#1 
		    \mdelimesize@\GivenSep
		 \or \mdelimesize@big\GivenSep
		  \or \mdelimesize@Big\GivenSep
		   \or \mdelimesize@bigg\GivenSep
		    \or \mdelimesize@Bigg\GivenSep
	\else
		\msize\GivenSep
	\fi}
}

%% méta-commandes internes pour construire des macros avec gestion 
%% des délimiteurs.

\def\dlm@last@arg{}
\def\dlm@mid@func#1{#1}
\def\after@xsubsup#1{\endgroup#1\endgroup}
\def\midProc#1{%
	\def\ProcessedArgument{\mid@lefthook#1\mid@righthook}
}
\def\mid@Proc#1{%
	\def\ProcessedArgument{#1}
}
\def\reset@Proc{\let\midProc\mid@Proc}
\let\mid@lefthook\@empty
\let\mid@righthook\@empty
\def\delimafterhook{}
\def\delimbeforehook{}
\NewDocumentCommand\dlm@lasthook@
	{
		m
		D""{\dlm@last@arg}
		t\stop
	}{
			\kern-2\nulldelimiterspace
			\mleft.
				\vphantom{\dlm@mid@func{\kill@mp{#1}}}
				\delimafterhook
			\mright.
			\@xp\after@xsubsup\@xp{#2}
			\IfBooleanF{#3}\delim
	}
\def\renew@delim#1#2#3#4{%
	\@xp\NewDocumentCommand\csname 
			delim@\romannumeral\dlm@count@%
		\endcsname
		{%
			>{\midProc}r#1#2 
			e{\ss} 
			E{_^}{{}{}} 
		}{
			\delimbeforehook
			\ifbr@@k
				\begin{multlined}[\vert@br@@k]
					\ldelimsize[##1]{#3}
					##1
					\rdelimsize[##1]{#4}
				\end{multlined}
			\else
				\ldelimsize{#3}\dlm@mid@func{##1}\rdelimsize{#4}
			\fi
			\IfValueTF{##2}
				{\def\x@subsup{\xsubsup[##2]}}
				{\def\x@subsup{\fake@subsup}}
			\x@subsup_{##3}^{##4}
			\dlm@lasthook@{##1}
		}
}
\def\renew@deliml#1#2{%
	\@xp\NewDocumentCommand\csname
			delim@\romannumeral\dlm@count@%
		\endcsname
		{%
			>{\midProc}r#1\. 
			e{\ss} 
			E{_^}{{}{}} 
		}{
	  		\delimbeforehook
			\ifbr@@k
				\begin{multlined}[\vert@br@@k]
					\ldelimsize[##1]{#2}##1\rdelimsize[##1].
				\end{multlined}
			\else
				\ldelimsize{#2} \dlm@mid@func{##1} \rdelimsize.
			\fi
			\IfValueTF{##2}
				{\def\x@subsup{\xsubsup[##2]}}
				{\def\x@subsup{\fake@subsup}}
			\x@subsup_{##3}^{##4}
			\dlm@lasthook@{##1}
		}
}
\def\renew@delimr#1#2{%
	\@xp\NewDocumentCommand\csname
			delim@\romannumeral\dlm@count@%
		\endcsname
		{%
			>{\midProc}r\.#1 
			e{\ss} 
			E{_^}{{}{}}
		}{
	  		\delimbeforehook
			\ifbr@@k
				\begin{multlined}[\vert@br@@k]
					\ldelimsize[##1]. ##1 \rdelimsize[##1]{#2}
				\end{multlined}
			\else
				\ldelimsize. \dlm@mid@func{##1} \rdelimsize{#2}
			\fi
			\IfValueTF{##2}
				{\def\x@subsup{\xsubsup[##2]}}
				{\def\x@subsup{\fake@subsup}}
			\x@subsup_{##3}^{##4}
			\dlm@lasthook@{##1}
		}
}
\def\renew@fdelim#1#2#3#4{%
	\@xp\NewDocumentCommand\csname
			delim@\romannumeral\dlm@count@%
		\endcsname
		{%
			>{\midProc}r#1#2 
			e{\ss} 
			E{_^}{{}{}} 
		}{
	  		\delimbeforehook
			\ifblank{##3}
				{\ifblank{##4}{{}##1{}}{\ldelimsize{#3}##1\rdelimsize{#4}}}
				{\ldelimsize{#3}##1\rdelimsize{#4}}
			%\ldelimsize{#3}##1\rdelimsize{#4}
			\IfValueTF{##2}
				{\def\x@subsup{\xsubsup[##2]}}
				{\def\x@subsup{\fake@subsup}}
			\x@subsup_{##3}^{##4}
			\delimafterhook
			\dlm@lasthook@
		}
}
\def\renew@normal@delim{%
	\@xp\NewDocumentCommand\csname
			delim@\romannumeral\dlm@count@%
		\endcsname
		{%
			>{\midProc}m 
			e{\ss} 
			E{_^}{{}{}} 
		}{
			\delimbeforehook
			\ifbr@@k
				\begin{multlined}[\vert@br@@k]
					##1
				\end{multlined}
			\else
				\dlm@mid@func{##1}
			\fi
			\IfValueTF{##2}
				{\def\x@subsup{\xsubsup[##2]}}
				{\def\x@subsup{\fake@subsup}}
			\x@subsup_{##3}^{##4}
			\dlm@lasthook@{##1}
		}
}
\def\renew@normal@fdelim{%
	\@xp\NewDocumentCommand\csname
			delim@\romannumeral\dlm@count@%
		\endcsname
		{%
			>{\midProc}m 
			e{\ss} 
			E{_^}{{}{}} 
		}{
			\delimbeforehook
			##1
			\delimafterhook
			\IfValueTF{##2}
				{\def\x@subsup{\xsubsup[##2]}}
				{\def\x@subsup{\fake@subsup}}
			\x@subsup_{##3}^{##4}
			\mleft.\vphantom{##1}\delimafterhook\mright.
			\dlm@lasthook@
		}
}
\def\dlm@dummy@{\dlm@lasthook@{\delimafterhook}\stop}
\NewDocumentCommand\create@basic@delim{
	m
	mm 
	O{#1}
}{
	\@xp\@xp\@xp\NewDocumentCommand\@xp
		\csname dlm@#1\endcsname
		{%
			>{\midProc}m 
			e{\ss} 
			E{_^}{{}{}}  
		}{
			\delimbeforehook
			\ifbr@@k
				\begin{multlined}[\vert@br@@k]
					\ldelimsize[##1]{#2}
					##1
					\rdelimsize[##1]{#3}
				\end{multlined}
			\else
				\ldelimsize{#2}\dlm@mid@func{##1}\rdelimsize{#3}
			\fi
			\IfValueTF{##2}
				{\def\x@subsup{\xsubsup[##2]}}
				{\def\x@subsup{\fake@subsup}}
			\x@subsup_{##3}^{##4}
			\dlm@lasthook@{##1}
		}
	\ifblank{#4}{}
		{\create@userdelim{#4}{#1}}
}
\def\create@userdelim#1#2{
	% #1 = user command name without \
	% #2 = backend shortcut to use 
	\@xp\@ifdefinable\csname #1\endcsname{
		\@xp\def
			\csname#1\@xp\endcsname\@xp{\csname dlm@#2\endcsname}
		\cspreto{#1}{\begingroup\dlm@PREPROCESS}
	}
}

%% construction des délimiteurs génériques

\create@basic@delim{prt}()
\create@basic@delim{brk}[]
\create@basic@delim{brc}\{\}
\create@basic@delim{abs}||
\create@basic@delim{norm}\|\|
\create@basic@delim{mnorm}\lVERT\rVERT
\create@basic@delim{ang}\langle\rangle
\create@basic@delim{flr}\lfloor\rfloor[floor]
\create@basic@delim{cil}\lceil\rceil[ceil]

\def\create@basic@delimbackend#1#2#3{
	% #1 = command name
	% #2 = left delim char
	% #3 = right delim char
	% #1=\prt, #2=(, #3=)  create \delim@prt : {} -> \dlm@PREPROCESS\dlm@prt
	\edef\dlm@name@@{\@xp\@gobble\string#1}
	\@xp\create@basic@delim\@xp{\dlm@name@@}#2#3[]
	\csedef{delim@\dlm@name@@}{
		\@xp\noexpand\csname dlm@\dlm@name@@\endcsname}
	\cspreto{delim@\dlm@name@@}{\dlm@PREPROCESS}
}
\def\declare@delimfrontend#1#2#3#4{
	% #1 = frontend command name
	% #2 = xparse arg specs 
	% #3 = defining code for \dlm@mid@func and \dlm@last@arg
	% #4 = backend command name
	\NewDocumentCommand#1{#2}{\begingroup#3#4}
}
\def\declare@delimfrontendcs#1#2#3#4{
	% #1 = frontend command name
	% #2 = xparse arg specs 
	% #3 = defining code for \dlm@mid@func and \dlm@last@arg
	% #4 = backend command name without \
	\def\N@D@C{\NewDocumentCommand#1{#2}}
	\begingroup
	\edef\cpge@tempd{\endgroup
		\expandonce\N@D@C{%
			\begingroup\unexpanded{#3}\@xp\noexpand\csname#4\endcsname
		}
	}
	\cpge@tempd
}

%%% ReNewDelim is used to have error messages with the cmd name.
%%% Too bad that xparse definitions are not patchable
\def\dlmpr@c{%
	\@ifnextchar({\renew@delim()()\next@delim}
	 {\@ifnextchar\{{\renew@delim\{\}\{\}\next@delim}
	  {\@ifnextchar[{\renew@delim[][]\next@delim}
	  {\@ifnextchar\lb{\renew@delim\lb\rb[]\next@delim}
	   {\@ifnextchar|{\renew@delim||||\next@delim}
	    {\@ifnextchar\|{\renew@delim\|\|\|\|\next@delim}
	     {\@ifnextchar\lV{\renew@delim\lV\rV\lVert\rVert\next@delim}
	       {\@ifnextchar\la{\renew@delim\la\ra\langle\rangle\next@delim}
	        {\@ifnextchar\lf{\renew@delim\lf\rf\lfoor\rfloor\next@delim}
	         {\@ifnextchar\lc{\renew@delim\lc\rc\lceil\rceil\next@delim}
	          {\@ifnextchar\bgroup{\renew@normal@delim\next@delim}
	           {\let\next@delim\dlm@dummy@\next@delim}
	}}}}}}}}}}
}
\def\dlm@fproc{%
	\@ifnextchar({\renew@fdelim()()\next@delim}
	 {\@ifnextchar\{{\renew@fdelim\{\}\{\}\next@delim}
	  {\@ifnextchar[{\renew@fdelim[][]\next@delim}
	   {\@ifnextchar|{\renew@fdelim||||\next@delim}
	    {\@ifnextchar\|{\renew@fdelim\|\|\|\|\next@delim}
	     {\@ifnextchar\lV{\renew@fdelim\lV\rV\lVert\rVert\next@delim}
	       {\@ifnextchar\la{\renew@fdelim\la\ra\langle\rangle\next@delim}
	        {\@ifnextchar\lf{\renew@fdelim\lf\rf\lfoor\rfloor\next@delim}
	         {\@ifnextchar\lc{\renew@fdelim\lc\rc\lceil\rceil\next@delim}
	          {\@ifnextchar\bgroup{\renew@normal@fdelim\next@delim}
	           {\let\next@delim\dlm@dummy@\next@delim}
	}}}}}}}}}
}
\def\dlmpr@cl{%
	\@ifnextchar({\renew@deliml((\next@delim}
	 {\@ifnextchar\{{\renew@deliml\{\{\next@delim}
	  {\@ifnextchar[{\renew@deliml[[\next@delim}
	   {\@ifnextchar|{\renew@deliml||\next@delim}
	    {\@ifnextchar\|{\renew@deliml\|\|\next@delim}
	     {\@ifnextchar\lV{\renew@deliml\lV\lVert\next@delim}
	       {\@ifnextchar\la{\renew@deliml\la\langle\next@delim}
	        {\@ifnextchar\lf{\renew@deliml\lf\lfoor\next@delim}
	         {\@ifnextchar\lc{\renew@deliml\lc\lceil\next@delim}
	          {\@ifnextchar\bgroup{\renew@normal@delim\next@delim}
	           {\let\next@delim\dlm@dummy@\next@delim}
	}}}}}}}}}
}
\def\dlmpr@cr{%
	\@ifnextchar({\renew@delimr((\next@delim}
	 {\@ifnextchar\{{\renew@delimr\{\{\next@delim}
	  {\@ifnextchar[{\renew@delimr[[\next@delim}
	   {\@ifnextchar|{\renew@delimr||\next@delim}
	    {\@ifnextchar\|{\renew@delimr\|\|\next@delim}
	     {\@ifnextchar\lV{\renew@delimr\lV\lVert\next@delim}
	       {\@ifnextchar\la{\renew@delimr\la\langle\next@delim}
	        {\@ifnextchar\lf{\renew@delimr\lf\lfoor\next@delim}
	         {\@ifnextchar\lc{\renew@delimr\lc\lceil\next@delim}
	          {\@ifnextchar\bgroup{\renew@normal@delim\next@delim}
	           {\let\next@delim\dlm@dummy@\next@delim}
	}}}}}}}}}
}
\def\next@delim{%
	\csname delim@\romannumeral\dlm@count@\endcsname
}
\NewDocumentCommand\AddProcDelim{mmmm}{
	\begingroup
	\edef\cpge@tmpa{%
		\unexpanded{\@ifnextchar#1{\renew@delim#1#2#3#4\next@delim}}
		 {\expandonce\dlmpr@c}
	}
	\@xp\gdef\@xp\dlmpr@c\@xp{\cpge@tmpa}
	\endgroup
}
\NewDocumentCommand\fAddProcDelim{mmmm}{
	\begingroup
	\edef\cpge@tmpa{%
		\unexpanded{\@ifnextchar#1{\renew@fdelim#1#2#3#4\next@delim}}
		 {\expandonce\dlm@fproc}
	}
	\@xp\gdef\@xp\dlm@fproc\@xp{\cpge@tmpa}
	\endgroup
}
\def\fdelim@{\dlm@PREPROCESS\dlm@fproc}
\def\delim@{\@ifstar{\dlm@PREPROCESS*\dlmpr@c@}{\dlm@PREPROCESS\dlmpr@c@}}
\DeclareRobustCommand\delim{%
	\begingroup
	\def\dlm@last@arg{}
	\def\dlm@mid@func##1{##1}
	\delim@
}
\DeclareRobustCommand\fulldelim[2][]{%
	\begingroup
	\@ifisnumber{#1}{\cpgesetupmath{max delim size=#1}}{}
	\noexpandarg\exploregroups
	\StrSubstitute{#2}{(}{\delim(}[\cpge@tmp]
	\@xp\StrSubstitute\@xp{\cpge@tmp}{[}{\delim[}[\cpge@tmp]
	\@xp\StrSubstitute\@xp{\cpge@tmp}{\{}{\delim\{}[\cpge@tmp]
	\@xp\StrSubstitute\@xp{\cpge@tmp}{\[}{[}[\cpge@tmp]
	\@xp\StrSubstitute\@xp{\cpge@tmp}{\]}{]}[\cpge@tmp]
	\cpge@tmp
	\endgroup
}
\DeclareRobustCommand\recdelim[2][]{%
	\begingroup
	\@ifisnumber{#1}{\cpgesetupmath{max delim size=#1}}{}
	\def\mid@lefthook{\delim}
	\def\fake@subsup{\xsubsup}
	\delim#2
	\endgroup
}
\NewDocumentCommand\fdelim{}{%
	\begingroup
	\def\dlm@last@arg{}
	\def\dlm@mid@func##1{##1}
	\fdelim@
}	
%%%% méta-commandes utilisateur pour construire des macros  gèrant les délimiteurs
%%%% 
%% Cree un synonyme de \delim
\def\dec@xdelim#1{%
	% #1 = user name of the command to become a synonym of \delim 
	\NewDocumentCommand#1{}{
		\begingroup
		\def\dlm@last@arg{}
		\def\dlm@mid@func####1{####1}
		\delim@
	}
}
%% prend en charge des arguments avant et apres le contenu a delimiter dynamiquement 
\def\xdec@xdelim#1#2#3{%
	% #1 = user command name
	% #2 = explicit left contents
	% #3 = explicit right contents
	\NewDocumentCommand#1{}{
		\begingroup
		\def\dlm@last@arg{#3}
		\def\dlm@mid@func####1{####1}
		#2\delim@
	}
}
%%% Meme chose mais permet des specifier le traitement du contenu a delimiter 
\def\Xdec@xdelim#1#2#3#4#5{%
	% #1 = user command name
	% #2 = xparse arg specs
	% #3 = left contents code
	% #4 = mid contents code, ##1 represents the contents between the delimiters
	% #5 = right contents code, 
	\NewDocumentCommand#1{#2}{%
		\begingroup
		 \def\dlm@last@arg{#5}
		 \ifblank{#4}
		 	{\def\dlm@mid@func####1{####1}}
			{\def\dlm@mid@func####1{#4}}
		 #3\delim@
	}
}
\def\Xdec@xdelim@star#1#2#3#4#5{%
	% #1 = user command name
	% #2 = xparse arg specs
	% #3 = left contents code
	% #4 = mid contents code, ##1 represents the contents between the delimiters
	% #5 = right contents code, 
	\NewDocumentCommand#1{#2}{%
		\begingroup
		 \def\dlm@last@arg{#5}
		 \ifblank{#4}
		 	{\def\dlm@mid@func####1{####1}}
			{\def\dlm@mid@func####1{#4}}
		 #3\delim@*
	}
}
\def\dec@delim#1#2#3{%
	% #1 = user command name
	% #2 = left delim
	% #3 = right delim
	\@ifdefinable{#1}{
		\create@basic@delimbackend{#1}{#2}{#3}
		\declare@delimfrontendcs{#1}{}
			{\def\dlm@last@arg{}\def\dlm@mid@func####1{####1}}
			{delim@\dlm@name@@}
	}
}
\def\xdec@delim#1#2#3#4#5{%
	% #1 = user command name, 
	% #2 = explicit left contents,
	% #3 = left delim, 
	% #4 = right delim, 
	% #5 = explicit right contents
	\@ifdefinable{#1}{
		\create@basic@delimbackend{#1}{#3}{#4}
		\declare@delimfrontendcs{#1}{}
			{\def\dlm@last@arg{#5}
				\def\dlm@mid@func####1{####1}#2}
			{delim@\dlm@name@@}
	}
}
\def\Xdec@delim#1#2#3#4#5#6#7{%
	% #1 = user command name, 
	% #2 = xparse arg specs for #1,
	% #3 = left contents code,
	% #4 = left delim, 
	% #5 = mid contents code, 
	% #6 = right delim
	% #7 = right contents code
	\@ifdefinable{#1}{
		\create@basic@delimbackend{#1}{#4}{#6}
		\declare@delimfrontendcs{#1}{#2}
			{\def\dlm@last@arg{#7}
				\ifblank{#5}
		 			{\def\dlm@mid@func####1{####1}}
					{\def\dlm@mid@func####1{#5}}
			#3}
			{delim@\dlm@name@@}
	}
}

\NewDocumentCommand\NewDelimiters{s}{%
	\IfBooleanTF{#1}{\dec@delim}{\dec@xdelim}}
\NewDocumentCommand\xDeclareDelimiters{s}{%
	\IfBooleanTF{#1}{\xdec@delim}{\xdec@xdelim}}
\NewDocumentCommand\XDeclareDelimiters{s}{%
	\IfBooleanTF{#1}{\Xdec@delim}{\Xdec@xdelim}}

\NewDocumentCommand\splittwoargs{
	m
	>{\SplitArgument{1}{,}}m
}{
	\split@func#1#2
}
\def\split@func#1#2#3{%
	\def\arg@one{#2}\def\arg@two{#3}%
	\ifdefvoid\arg@one{\def\arg@one{\cdot}}{}%
	\ifdefvoid\arg@two{\def\arg@two{\cdot}}{}%
	\IfNoValueTF{#3}
		{\cdot\,#1\,\cdot}
		{\arg@one\,#1\,\arg@two}%
}
\NewDocumentCommand\splitargsrec{
	m
	>{\SplitArgument{10}{,}}m
}{
	\split@funcrec#1#2
}
\def\split@funcrec#1#2#3{%
	\ifblank{#2}
		{\ifblank{#3}{\cdot\,#1\,\cdot}{\cdot\,#1\,#3}}
		{\ifblank{#3}{#2\,#1\,\cdot}{#2\,#1\,#3}}%
}

%% définitions des macros utilisateurs génériques

\XDeclareDelimiters*\iic{}{}\lBrack{\splittwoargs\IntSep{##1}}\rBrack{}
\XDeclareDelimiters*\icc{}{}[{\splittwoargs\IntSep{##1}}]{}
\XDeclareDelimiters*\ico{}{}[{\splittwoargs\IntSep{##1}}[{}
\XDeclareDelimiters*\ioc{}{}]{\splittwoargs\IntSep{##1}}]{}
\XDeclareDelimiters*\ioo{}{}]{\splittwoargs\IntSep{##1}}[{}
\XDeclareDelimiters*\sprod{}{\reset@Proc}\langle{\splittwoargs\SprodSep{##1}}\rangle{}

%%%% \interv macros plus pratique pour les intervalles
\newif\ifdouble@fence
\let\interv@tok\@empty
\forcsvlist{\listadd\i@fences}{[,]}
\csdef{[@}{\ldelimsize{[}}
\csdef{]@}{\ldelimsize{]}}
\csdef{[@double}{\ldelimsize{\lBrack}}
\csdef{]@double}{\ldelimsize{\rBrack}}
\csdef{@[}{\rdelimsize{[}}
\csdef{@]}{\rdelimsize{]}}
\csdef{double@[}{\rdelimsize{\lBrack}}
\csdef{double@]}{\rdelimsize{\rBrack}}
\def\interv@#1{
	\ifinlist#1\i@fences
		{%
			\@xp\splittwoargs\@xp\IntSep\@xp{\inter@tok}
			\csuse{\ifdouble@fence double\fi @#1}
			\endgroup\endgroup
		}{
			\appto\inter@tok{#1}
			%\show\inter@tok
			\interv@	
		}
}
\def\@interv#1#2{
	\ifinlist#1\i@fences
		{
			\ifstrequal{#1}{#2}
				{\csuse{#1@double}\double@fencetrue\interv@}
				{\csuse{#1@}\appto\inter@tok{#2}\interv@}
		}{%
			\cpgemath@err
				{\string\interv\space:\space
				#1 n'est pas un délimiteur valide}
				{}
		}
}
\newcommand\interv{%
	\begingroup
	\dlm@PREPROCESS\@interv
}
\newcommand\ii{%
	\begingroup
	\dlm@PREPROCESS\@interv
}	

\XDeclareDelimiters*\xnorm{}{\reset@Proc}\lVert{\ifblank{##1}{\,\cdot\,}{##1}}\rVert{}
\XDeclareDelimiters*\xmnorm{}{\reset@Proc}\lVERT{\ifblank{##1}{\,\cdot\,}{##1}}\rVERT{}
\XDeclareDelimiters*\ippc{}{\def\x@subsup{\xsubsup}}[{##1}]{}
\XDeclareDelimiters*\class{E{^}{{}}}{\Clsymb\ifblank{#1}{}{^{#1}}}({##1}){}

\newcommand\ens{}
\def\ens{\brc}

\XDeclareDelimiters\xPr{e{_}}
	{\IfValueTF{#1}{\opn{\Psymb}_{#1}}{\opn{\Psymb}}}
	{##1}
	{}
\XDeclareDelimiters\xEs{e{_}}
	{\IfValueTF{#1}{\opn{\Esymb}_{#1}}{\opn{\Esymb}}}
	{##1}
	{}
\XDeclareDelimiters\xVa{e{_}}
	{\IfValueTF{#1}{\opn{\Vsymb}\xsubsup[h=4,b=-3]_{#1}}{\opn{\Vsymb}}}
	{##1}
	{}
\XDeclareDelimiters\xgo{e{_}}
	{\IfValueTF{#1}{\opn{\Osymb}_{#1}}{\opn{\Osymb}}}
	{##1}
	{}
\XDeclareDelimiters\xpo{E{\ss}{{}} e{_}}
	{\IfValueTF{#2}{\opn{\osymb}\xsubsup[ss,b=-3,h=3,#1]_{#2}}{\opn{\osymb}}}
	{##1}
	{}
	
%% intégrale, sommes, produits et grands opérateurs

\newcount\var@count
\newcount\int@count

\newcommand\bigopind[1]{%
	\ifblank{#1}{}
		{
			\var@count\z@
			\def\do##1{
				\advance\var@count\@ne
				\csdef{k\romannumeral \var@count}{##1}
			}
			\docsvlist{#1}
		}
}
\bigopind{k,n,p}
\cpgesetupmath{
	big operator indices/.code	= \bigopind{#1},
	boi/.style					= {big operator indices={#1}}
}
\NewDocumentCommand\XDeclareBigOperator{mm}{%
	\XDeclareDelimiters#1
	{
		s
		e{\ss} 
		E{_^}{{}{}} 
		e{\es\vr} 
	}{
		\IfValueT{##6}{
			\bigopind{##6}
		}
		\IfValueTF{##2}
			{\def\x@subsup{\xsubsup[noadjust,##2]}}
			{\def\x@subsup{\fake@subsup}}
		\IfBooleanT{##1}{\let\ss@limits\limits}
		\@xp#2\ss@limits
			\x@subsup_{##3}^{##4}
		\IfValueT{##5}{\ifblank{##5}{\xpush{m}}{\xpush{##5}}}
	}
	{}{\var@count\z@}
	\@xp\XDeclareDelimiters\csname\@xp\@gobble\string#1d\endcsname
		{}
		{\reset@Proc}
		{#1 ####1}
		{}
}
\XDeclareBigOperator\xsum\sum
\XDeclareBigOperator\xprod\prod
\XDeclareBigOperator\xcup\bigcup
\XDeclareBigOperator\xcap\bigcap
\XDeclareBigOperator\xoplus\bigoplus


%%% Integrales 
\newcommand\intvar[1]{%
	\ifblank{#1}
		{}
		{
			\var@count\z@
			\def\do##1{
				\advance\var@count\@ne
				\csdef{t\romannumeral \var@count}{##1}
				\csdef{dt\romannumeral \var@count}{\diff##1}
			}
			\docsvlist{#1}
		}
}
\intvar{t,x,u}
\cpgesetupmath{
	integrale variables/.code	= \intvar{#1},
	iv/.style					= {integrale variables={#1}}
}
\XDeclareDelimiters\xint
{
	s 
	e{\ss} 
	E{_^}{{}{}} 
	E{\es\vr}{{@}{@}} 
}{%
	\advance\int@count by \@ne\relax
	\ifstrequal{#6}{@}{}{\intvar{#6}}
	\IfValueTF{#2}
		{\def\x@subsup{\xsubsup[noadjust,nl,ns,#2]}}
		{\def\x@subsup{\fake@subsup}}
	\IfBooleanTF{#1}
		{\let\ss@limits\limits}
		{\let\ss@limits\nolimits}
	\@xp\int\ss@limits
	\x@subsup_{#3}^{#4}
	\ifstrequal{#5}{@}{}
		{\ifblank{#5}{\xpush{b}}{\xpush{#5}}}
}{\xint@diffint ##1}
{\csuse{dt\romannumeral\int@count}}

\def\xint@diffint{%
	\csappto{dt\romannumeral\int@count}{\csgundef{dt\romannumeral\int@count}}
}
\XDeclareDelimiters\xintd{}{}{\xint ##1}{}

%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%% cases %%%%%%%%%
%%% emprunts à mathtools.sty
\def\dsts@cases#1#2#3{
	\vcenter{
		\Let@ \chardef\dspbrk@context\@ne \restore@math@cr
		\let  \math@cr@@\AMS@math@cr@@
		\spread@equation
		\ialign{
			\;\strut@#1\hfil &\quad \strut@#2\hfil
		  	\crcr
				#3
			\crcr}
		\restorecolumn@
		}
}
\def\cmd@cases{\dsts@cases{$\m@th\displaystyle##$}{$\m@th\displaystyle##$}}
\Xdec@xdelim@star\xcases{s}{%
	\IfBooleanT{#1}
		{\def\cmd@cases{\dsts@cases{$\m@th####$}{$\m@th####$}}}
	\def\dlmpr@c@{\dlmpr@cl}
}{\cmd@cases{##1}}{}

%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Les matrices %%%%%%

%% Emprunt des fonctions essentielles a mathtools.sty
\MHInternalSyntaxOn
	\def\n@matrix@in{\MT_matrix_begin:N}
	\def\n@matrix@out{\MT_matrix_end:}
	\def\s@matrix@in{\MT_smallmatrix_begin:N}
	\def\s@matrix@out{\MT_smallmatrix_end:}
\MHInternalSyntaxOff
\def\matrix@in{\n@matrix@in}
\def\matrix@out{\n@matrix@out}
\XDeclareDelimiters\xmatrix
	{
		t\s 
		E{\al}{c} 
	}{%
		\IfBooleanT{#1}{%
			\def\matrix@in{\s@matrix@in}%
			\def\matrix@out{\s@matrix@out}%
		}%
		\def\coeff@align{#2}%
	}
	{\@xp\matrix@in\coeff@align ##1 \matrix@out}
	{}
\NewDocumentEnvironment{Xmatrix}{b}{\xmatrix#1}{}
%%%%%%%%% Petits opérateurs

%%% les petites fonctions qui manquent en français
\def\card{\qopname\relax o{card}}
\def\codim{\qopname\relax o{codim}}
\def\cotan{\qopname\relax o{cotan}}
\def\cotanh{\qopname\relax o{cotanh}}
\def\det{\qopname\relax o{det}} % indice/exposant normaux
\def\Es{\qopname\relax o{\Esymb}}
\def\im{\qopname\relax o{Im}}
\def\ker{\qopname\relax o{Ker}}
\def\pgcd{\qopname\relax m{pgcd}}
\def\ppcm{\qopname\relax m{ppcm}}
\def\Pr{\qopname\relax o{\Psymb}}
\def\rang{\qopname\relax o{rang}}
\def\re{\qopname\relax o{Re}}
\def\rg{\qopname\relax o{rg}}
\def\sign{\qopname\relax o{sign}}
\def\tr{\qopname\relax o{tr}}
\def\val{\qopname\relax o{val}}
\def\vect{\qopname\relax o{vect}}
\def\com{\qopname\relax o{Com}}
\let\Com\com
\def\id{\qopname\relax o{id}}
\def\diag{\qopname\relax o{diag}}
\def\Va{\qopname\relax o{\Vsymb}}

%%% équivalent de \operatorname mais qui gère les délimiteurs
\XDeclareDelimiters\xoperatorname{s e{\ss} m E{_^}{{}{}}}
	{
		\IfValueT{#2}{\def\x@subsup{\xsubsup[#2]}}
		\IfBooleanTF{#1}
			{\qopname\newmcodes@ m{#3}}
			{\qopname\newmcodes@ o{#3}}
		\x@subsup_{#4}^{#5}
	}{}{}
\DeclareRobustCommand{\xopn}{\@ifstar{\xoperatorname*}{\xoperatorname}}

%%% équivalent de \NewMathOperator mais qui crée des commandes 
%%% capable de gérer les délimiteurs

\def\declare@mathoperator#1#2#3{%
	\if #1m
		\XDeclareDelimiters#2{s e{\ss} E{_^}{{}{}}}
			{
				\IfValueTF{##2}
					{\def\x@subsup{\xsubsup[h=-2,b=5,##2]}}
					{\def\x@subsup{\fake@subsup}}
				\qopname\newmcodes@ m{#3}
				\IfBooleanT{##1}{\limits}
				\x@subsup_{##3}^{##4}
			}{}{}
	\else 
		\XDeclareDelimiters#2{s e{\ss} E{_^}{{}{}}}
			{
				\IfValueT{##2}{\def\x@subsup{\xsubsup[h=-2,t=0,##2]}}
				\qopname\newmcodes@ o{#3}
				\IfBooleanT{##1}{\displaylimits\limits}
				\x@subsup_{##3}^{##4}
			}{}{}
	\fi
}

\NewDocumentCommand\XDeclareMathOperator{s}{
	\IfBooleanTF{#1}{\declare@mathoperator m}{\declare@mathoperator o}
}
\@onlypreamble\XDeclareMathOperator

\def\xopn@for#1{%
	\@xp\XDeclareMathOperator\csname x#1\endcsname{#1}}
\forcsvlist\xopn@for{%
    arccos,
    arcsin,
    arctan,
    arg,
    card,
    codim,
    cos,
    cosh,
    cotan,
    cotanh,
    deg,
    det,
    dim,
    exp,
    id,
    Im,
    ln,
    log,
    rg,
    rang,
    sign,
    sin,
    sinh,
    tan,
    tanh,
    tr,
	val 
}
\XDeclareMathOperator\xker{Ker}
\XDeclareMathOperator\xim{Im}
\XDeclareMathOperator\xcom{Com}
\XDeclareMathOperator\xre{Re}
\XDeclareMathOperator\xvect{Vect}
\XDeclareMathOperator*\xpgcd{pgcd}
\XDeclareMathOperator*\xppcm{ppcm}
\XDeclareMathOperator*\xmax{max}
\XDeclareMathOperator*\xmin{min}
\XDeclareMathOperator*\xlim{lim}
\XDeclareMathOperator*\xliminf{lim\,inf}
\XDeclareMathOperator*\xlimsup{lim\,sup}
\XDeclareMathOperator*\xinf{inf}
\XDeclareMathOperator*\xsup{sup}

\NewDocumentCommand\OV{O{2}m}{%
	{}\mkern#1mu
	\overline{
		\cramped{\mkern-#1mu#2}
	}
}
%%%%% fonctions
%%% \fct obsolète, maintenue pour compatibilité avec mes anciens documents
\newcommand{\fct}[5][rcl]{%
	\begin{array}[t]{#1}
		#2 & \longrightarrow & #3 \\
		#4 & \longmapsto     & #5
	\end{array}
}
\NewDocumentCommand\func{s}{%
	\IfBooleanTF{#1}
		{\cpge@func}
		{\cpge@Func}
}
\def\cpge@func#1#2#3{%
	\@ifempty{#1}
		{}
		{#1\::\:}%
	#2\longmapsto#3%
}
\def\cpge@Func{%
	\@ifnextchar[
		{\cpge@Func@}
		{\cpge@Func@[rcl]}
}
\def\cpge@Func@[#1]#2#3#4#5#6{%
	\begingroup%
		\@ifempty{#2}
			{\def\ar@opt{c}}
			{\def\ar@opt{t}#2\::\:}%
	\begin{array}[\ar@opt]{#1}
		#3&\longrightarrow& #4\\ 
		#5&\longmapsto&#6
	\end{array}%
	\endgroup
}
\NewDocumentCommand\funcalt{O{rcl}}{%
	\cpge@funcalt[#1]
}
\def\cpge@funcalt[#1]#2#3#4#5#6{%
	\begingroup%
		\@ifempty{#2}
			{}
			{#2\::\:}%
		\left\{\begin{array}{#1}
			#3&\longrightarrow& #4\\
			#5&\longmapsto&#6
		\end{array}\right.%
	\endgroup
}	
%%%%% Dérivation

%%%%% Code from diffcoef.sty
%%%%% tribute to Andrew Parsloe
\ExplSyntaxOn
\tl_const:Nn \c__cpgemath_digits_tl { 1234567890 }
\seq_new:N \l__cpgemath_orders_seq
\seq_new:N \l__cpgemath_vars_seq
\seq_new:N \l__cpgemath_denom_seq
\seq_new:N \l__cpgemath_paren_seq
\prop_new:N \l__cpgemath_vars_prop
\int_new:N \l__cpgemath_curr_tok_int
\int_new:N \l__cpgemath_curr_state_int
\int_new:N \l__cpgemath_nos_int
\int_new:N \l__cpgemath_parenvar_int

\msg_new:nnn { cpgemath } { order-specification } 
  {
    \iow_newline:
    charactère~#3~suivi~de~#2~dans~les~spécifications~des~ordres
    ~[#1]~\msg_line_context:.~
    cpgemath~ne~peut~pas~calculer~l'ordre~total~dans~ce~cas.
  }

%%%%
\cs_new:Npn \__cpgemath_calc_tot_order:NN #1 #2
  {
    \tl_clear:N \l__cpgemath_nos_tl
    \exp_args:Nx\__cpgemath_digest_expr:n { \seq_use:Nn #1 { + } }
    \prop_if_empty:NTF \l__cpgemath_vars_prop
      { \tl_set:NV #2 \l__cpgemath_nos_tl }
      { \__cpgemath_evaluate:NN \l__cpgemath_vars_prop #2 }
  }
%%%%%
\cs_new:Npn \__cpgemath_digest_expr:n #1
  {
    \tl_set:Nn \l__cpgemath_curr_num_tl { + }
    \tl_set:Nn \l__cpgemath_paren_tl { +1 }
    \tl_set:Nn \l__cpgemath_nos_tl { 0 }
    \int_zero:N \l__cpgemath_curr_state_int
    \int_zero:N \l__cpgemath_curr_tok_int
    \tl_map_inline:nn { #1+ }
      { 
        \__cpgemath_get_curr_ndx:nN { ##1 } \l__cpgemath_curr_tok_int
        \__cpgemath_transitions:nNN { ##1 } 
            \l__cpgemath_curr_state_int \l__cpgemath_curr_tok_int 
      }
    \int_set:Nn \l__cpgemath_nos_int { \l__cpgemath_nos_tl }
    \tl_set:Nx \l__cpgemath_nos_tl { \int_use:N \l__cpgemath_nos_int }
    \int_compare:nNnT { \l__cpgemath_nos_int } = { 0 }
      { \tl_clear:N \l__cpgemath_nos_tl }
  }
% #1 curr tok (tl); #2 <== curr tok ndx (int)
%%%%%%%
\cs_new_protected:Npn \__cpgemath_get_curr_ndx:nN #1#2
  { 
    \tl_if_in:NnTF \c__cpgemath_digits_tl { #1 }
      { \int_set:Nn #2 { 1 } } % digit
      { 
        \str_case:nnF { #1 }
          {
            { + } { \int_set:Nn #2 { 0 } }
            { - } { \int_set:Nn #2 { 0 } }
            { ( } { \int_set:Nn #2 { 3 } }
            { ) } { \int_set:Nn #2 { 4 } }
          }
          { \int_set:Nn #2 { 2 } }  % var
      }
  }
% #1(tl) curr tok; #2(int) curr state; #3(int) curr tok ndx
%%%%%%%%
\cs_new:Npn \__cpgemath_transitions:nNN #1#2#3
  { 
    \int_case:nn { #2 }
      { 
        { 0 } % sgn + -
          { \__cpgemath_sgn_transitions:nNN { #1 }#2#3 }
        { 1 } % num 
          { \__cpgemath_num_transitions:nNN { #1 }#2#3 }
        { 2 } % alg
          { \__cpgemath_alg_transitions:nNN { #1 }#2#3 }
        { 4 } % )
          { \__cpgemath_rpar_transitions:nNN { #1 }#2#3 }
      }
  }
% transitions from the signed state
% #1(tl) curr tok; #2(int) 0, curr state; #3 curr tok ndx
%%%%%%
\cs_new_protected:Npn \__cpgemath_sgn_transitions:nNN #1#2#3
  {
    \int_case:nnT { #3 }
      {
        { 0 } % tok = s
          {
            \tl_if_eq:nVTF { #1 } \l__cpgemath_curr_num_tl
              { \tl_set:Nn \l__cpgemath_curr_num_tl { + } }
              { \tl_set:Nn \l__cpgemath_curr_num_tl { - } }
          }
        { 1 } % tok = d
          { \tl_put_right:Nn \l__cpgemath_curr_num_tl { #1 } }
        { 2 } % tok = v
          {
            \tl_put_right:Nn \l__cpgemath_curr_num_tl { 1 }
            \tl_set:Nn \l__cpgemath_curr_var_tl { #1 }
          }
        { 3 } % tok = (
          {
            \seq_push:NV \l__cpgemath_paren_seq \l__cpgemath_paren_tl
            \tl_put_left:NV \l__cpgemath_paren_tl \l__cpgemath_curr_num_tl
            \tl_set:Nn \l__cpgemath_curr_num_tl { + }
            \int_set:Nn #3 { 0 }
          }
      }
      { \int_set_eq:NN #2 #3 }
  }
% transitions from the numeric state
% #1 = curr. tok.; #2 = 0, curr. state; #3 curr. tok. index
%%%%%%%%
\cs_new_protected:Npn \__cpgemath_num_transitions:nNN #1#2#3
  {
    \int_case:nnT { #3 }
      {
        { 0 } % tok = s
          {
            \tl_put_right:NV\l__cpgemath_nos_tl 
              { \l__cpgemath_paren_tl * \l__cpgemath_curr_num_tl }
            \tl_set:Nn \l__cpgemath_curr_num_tl { #1 } 
          }
        { 1 } % tok = d
          { \tl_put_right:Nn \l__cpgemath_curr_num_tl { #1 } }
        { 2 } % tok = v
          {
            \tl_if_in:nnTF { ^ \times * / \div } { #1 }
              {
                \msg_error:nnxxx { cpgemath } { order-specification } 
                { \seq_use:Nn \l__cpgemath_orders_seq { , } } 
                { #1 } { number }
              }
              { \tl_set:Nn \l__cpgemath_curr_var_tl { #1 } }
          }
        { 3 } % tok = (
          { 
            \seq_push:NV \l__cpgemath_paren_seq \l__cpgemath_paren_tl
            \tl_put_left:Nn \l__cpgemath_paren_tl { * }
            \tl_put_left:NV \l__cpgemath_paren_tl \l__cpgemath_curr_num_tl
             \tl_set:Nn \l__cpgemath_curr_num_tl { + }
            \int_set:Nn #3 { 0 } 
          }
        { 4 } % tok = )
          {
            \tl_put_right:NV \l__cpgemath_nos_tl 
                { \l__cpgemath_paren_tl * \l__cpgemath_curr_num_tl }
          }
      }
      { 
        \int_set_eq:NN #2 #3 }
  }
% transitions from the algebraic state
% #1 = curr. tok.; #2 = 2, curr. state; #3 curr. tok. index
%%%%%%%%%
\cs_new:Npn \__cpgemath_alg_transitions:nNN #1#2#3
  { 
    \int_case:nnT { #3 }
      {
        { 0 } % tok = s
          { 
            \int_compare:nNnTF { \l__cpgemath_parenvar_int } = { 0 }
              {
                \__cpgemath_store_var:NNN \l__cpgemath_curr_var_tl
                    \l__cpgemath_paren_tl \l__cpgemath_curr_num_tl
                \tl_clear:N \l__cpgemath_curr_var_tl
                \tl_set:Nn \l__cpgemath_curr_num_tl { #1 }
              }
              {
                \tl_put_right:Nn \l__cpgemath_curr_var_tl { #1 }
                \int_set:Nn #3 { 2 }
              }
          }
        { 1 } % tok = d
          { 
            \tl_put_right:Nn \l__cpgemath_curr_var_tl { #1 } 
            \int_set:Nn #3 { 2 }
          }
        { 2 } % tok = v
          { \tl_put_right:Nn \l__cpgemath_curr_var_tl { #1 } }
        { 3 } % tok = (
          {
            \tl_put_right:Nn \l__cpgemath_curr_var_tl { #1 }
            \int_set:Nn #3 { 2 }
            \int_incr:N \l__cpgemath_parenvar_int
          }
        { 4 } % tok = )
          {
            \int_compare:nNnTF { \l__cpgemath_parenvar_int } = { 0 }
              {
                \__cpgemath_store_var:NNN \l__cpgemath_curr_var_tl
                    \l__cpgemath_paren_tl \l__cpgemath_curr_num_tl
                \tl_clear:N \l__cpgemath_curr_var_tl
              }
              {
                \tl_put_right:Nn \l__cpgemath_curr_var_tl { #1 }
                \int_set:Nn #3 { 2 }
                \int_decr:N \l__cpgemath_parenvar_int
              }
          }
      }
      { \int_set_eq:NN #2 #3 }
  }
% transitions from the ) state
% #1 = curr. tok.; #2 = 4, curr. state; #3 curr. tok. index
%%%%%%%%%%%
\cs_new:Npn \__cpgemath_rpar_transitions:nNN #1#2#3
  {
    \int_compare:nNnTF { \int_mod:nn { #3 } { 4} } = { 0 }
      { 
        \tl_set:Nn \l__cpgemath_curr_num_tl { #1 }
        \seq_pop:NN \l__cpgemath_paren_seq \l__cpgemath_paren_tl
        \int_set_eq:NN #2 #3
      }
      {
        \msg_error:nnxxx { cpgemath } { order-specification } 
            { \seq_use:Nn \l__cpgemath_orders_seq { , } } { #1 } { ) }
      }
  }
% #1 is var. (tlvar); #2 is num. (tlvar); #3 num. coeff. (tlvar)
\cs_new:Npn \__cpgemath_store_var:NNN #1#2#3
  {
    \prop_get:NVNF \l__cpgemath_vars_prop #1 \l_tmpa_tl
      { \tl_clear:N \l_tmpa_tl }
    \tl_put_right:NV \l_tmpa_tl { #2 * #3 }
    \prop_put:NVV \l__cpgemath_vars_prop #1 \l_tmpa_tl
  }
% #1 (propv) key=var, val=coeff; #2 <= total order
%%%%%%
\cs_new_protected:Npn \__cpgemath_evaluate:NN #1#2
  {
    \prop_map_inline:Nn #1 { \seq_put_left:Nn \l_tmpa_seq { ##1 } }
    \seq_sort:Nn \l_tmpa_seq
      {
        \int_compare:nNnTF { \tl_count:n { ##1 } } < { \tl_count:n { ##2 } }
          { \sort_return_same: } { \sort_return_swapped: }
      }
    \seq_map_inline:Nn \l_tmpa_seq
      {
        \prop_pop:NnN #1 { ##1 } \l_tmpb_tl
        \seq_put_right:Nx \l_tmpb_seq { \int_eval:n \l_tmpb_tl }
       }
    \tl_clear:N \l_tmpa_tl
    \seq_mapthread_function:NNN \l_tmpa_seq \l_tmpb_seq 
        \__cpgemath_tot_order:nn
    \exp_args:NV \tl_if_head_eq_charcode:nNTF \l_tmpa_tl +
      { 
        \tl_set:Nx \l_tmpb_tl { \tl_tail:N \l_tmpa_tl }
        \int_compare:nNnT { \l__cpgemath_nos_int } > { 0 }
          { \tl_put_left:Nn \l__cpgemath_nos_tl { + } }
         \tl_concat:NNN #2 \l_tmpb_tl \l__cpgemath_nos_tl
      }
      { 
        \int_compare:nNnTF { \l__cpgemath_nos_int } > { 0 }
          { \tl_concat:NNN #2 \l__cpgemath_nos_tl \l_tmpa_tl }
          { \tl_concat:NNN #2 \l_tmpa_tl \l__cpgemath_nos_tl }
      }
    \tl_set_rescan:Nno #2 { } #2
  }
%%%%%%
\cs_new:Npn \__cpgemath_tot_order:nn #1#2
  { 
    \int_compare:nNnTF { #2 } > { 0 }
      { 
        \int_compare:nNnTF { #2 } = { 1 }
          { \tl_put_left:Nn \l_tmpa_tl { +#1 } }
          { \tl_put_left:Nn \l_tmpa_tl { +#2#1 } }
      }
      {
        \int_compare:nNnT { #2 } < { 0 }
          { 
            \int_compare:nNnTF { #2 } = { -1 }
              { \tl_put_right:Nn \l_tmpa_tl { -#1 } }
              { \tl_put_right:Nn \l_tmpa_tl { #2#1 } }
          }
      }
  }

\NewDocumentCommand\calc@totorder{ mm }
	{
		\seq_set_from_clist:Nn \l__cpgemath_orders_seq { #2 }
		\__cpgemath_calc_tot_order:NN  \l__cpgemath_orders_seq #1
	}

\ExplSyntaxOff

\def\get@arg#1^{#1}
\def\get@var#1{\get@var@#1^\cpge@nil}
\let\der@var\@empty
\let\order@csv\@empty
\def\get@var@#1^#2\cpge@nil{%
	\ifblank{#2}
		{%
			\def\cpge@tmpo{1}
			\appto\order@csv{, 1}
			\eappto\der@var{\@nx\diff@sym #1}
		}{%
			\edef\cpge@tmpo{\get@arg #2}
			\eappto\order@csv{, \cpge@tmpo}
			\eappto\der@var{\@nx\diff@sym #1\@nx\xsubsup[h=0,t=0]^{\cpge@tmpo}}
		}
}
\XDeclareDelimiters\xder{s e{\or\vl} mm }
	{%	
		\def\diff@sym{\dsymb}
		\get@var{#5}
		\ifdefstring{\cpge@tmpo}{1}
			{\def\der@func{\diff@sym #4}}
			{\def\der@func{\diff@sym\xsubsup[h=-2]^{\cpge@tmpo}#4}}
		\def\der@frac{%
			\IfBooleanTF{#1}
				{\xfrac*{\der@func}{\der@var}}
				{\xfrac[d=\fake@cmd]{\der@func}{\der@var}}
		}
		\IfValueT{#3}
			{\def\delimafterhook{\vphantom{\der@frac}\,\vrule}}
		\der@frac
	}
	{##1}
	{\IfValueT{#3}{\xsubsup[h=0,cs]_{#3}}}
	
\XDeclareDelimiters\xderp{s e{\or\vl} mm }
	{%	
		\let\der@var\@empty
		\let\order@csv\@empty
		\def\diff@sym{\partial}
		\forcsvlist\get@var{#5}
		\@xp\calc@totorder\@xp\cpge@tmpo\@xp{\order@csv}
		\IfValueT{#2}{\def\cpge@tmpo{#2}}
		\ifdefstring{\cpge@tmpo}{1}
			{\def\der@func{\diff@sym #4}}
			{\def\der@func{\diff@sym\xsubsup[h=-2,t=0]^{\cpge@tmpo}#4}}
		\def\der@frac{%
			\IfBooleanTF{#1}
				{\xfrac*{\der@func}{\der@var}}
				{\xfrac[d=\fake@cmd]{\der@func}{\der@var}}
		}
		\IfValueT{#3}
			{\def\delimafterhook{\vphantom{\der@frac}\,\vrule}}
		\der@frac
	}
	{##1}
	{\IfValueT{#3}{\xsubsup[h=0,cs]_{#3}}}

\XDeclareDelimiters\xdiff{E{^_}{{}{}} m}
	{
		\opn{\dsymb}
		\xsubsup[h=0,b=-2]^{#1}_{#2}
		\xpush{-1}#3
	}{##1}{}
\XDeclareDelimiters\xDiff{E{^_}{{}{}} m}
	{
		\opn{\Dsymb}
		\xsubsup[h=0]^{#1}_{#2}
		\xpush{-1}#3
	}{##1}{}
	
	
%%% Matrices


%%%%% Vieilles macros (obsolete)

\let\opn\operatorname

%% Probas
\DeclareRobustCommand\lrfloor[1]{\lfloor#1\rfloor}
\DeclareRobustCommand\PP{\opn{\Psymb}}
\DeclareRobustCommand\EE{\opn{\Esymb}}
\DeclareRobustCommand\VV{\opn{\Vsymb}}
\DeclareRobustCommand\tsprod{\mathop{\mathchar"1351}}
\DeclareRobustCommand\tssum{\mathop{\mathchar"1350}}
\DeclareRobustCommand\lsum{\sum\limits}
\DeclareRobustCommand\lprod{\prod\limits}
\DeclareRobustCommand\lcap{\bigcap\limits}
\DeclareRobustCommand\lcup{\bigcup\limits}
\DeclareRobustCommand\llim{\lim\limits}
\DeclareRobustCommand\sim{\mathop{\mathchar"3218}}
\DeclareRobustCommand\lsim{\sim\limits}
\let\@longleftarrow\longleftarrow
\DeclareRobustCommand\longleftarrow{\mathop{\@longleftarrow}}
\let\@longrightarrow\longrightarrow
\DeclareRobustCommand\longrightarrow{\mathop{\@longrightarrow}}

%% algèbre et arithmétique
\def\sgpe#1{\langle #1\rangle}
\def\ntr#1#2{\mathbf{#1}_{#2}}
\let\xtor\texorpdfstring
\let\divise\mid
\let\nodivise\nmid
\DeclareRobustCommand\modulo[3]{#1\equiv#2\quad[#3]}
\DeclareRobustCommand\OV{\@ifnextchar[\OVC\OVN}
\let\OVN\overline
\NewDocumentCommand\OVC{om}{\cramped{\OVN{#2}^{[#1]}}}
\DeclareRobustCommand\sign{\opn{sign}}
\DeclareRobustCommand\downeq{\underset{\smash{\downarrow}}=}
\DeclareRobustCommand\upeq{\overset{\smash{\uparrow}}=}


%% normes,
\newcommand\nm[1]{\left\Vert#1\right\Vert}
\newcommand\nmm[1]{|\!|\!|#1|\!|\!|}
\newcommand\pds[1]{\langle #1\rangle}

%% constante

%%%%%%%% raccourcis très utilisés, 
%%%%%%%% conservé pour compatibilté
\let\ds\displaystyle
\let\ts\textstyle
\let\leq\leqslant
\let\geq\geqslant
\DeclareRobustCommand\setminus{\mathbin{\smallsetminus}}
\let\ssi\Longleftrightarrow
\let\lra\longrightarrow
\let\Lra\Longrightarrow
\let\Llra\Longleftrightarrow
\let\cqfd\qed
\let\nom\textsc
\newcommand\be{\begin{xenum}}
\newcommand\ee{\end{xenum}}
\newcommand\bi{\begin{xitem}}
\newcommand\ei{\end{xitem}}
\newcommand\bca{\begin{dcases}}
\newcommand\eca{\end{dcases}}
\makeatletter
	\def\dt{{\operator@font d}}
	\def\d{{\operator@font d}}
\makeatother
\def\dd#1#2{
	\frac{\partial#1}{\partial#2}
  }
\def\ddeux#1#2#3{
	\def\a{#2}\def\b{#3} 
	\ifx\a\b \frac{\partial^{2}#1}{\partial\a^{2}}
	\else \frac{\partial^{2}#1}{\partial\a\partial\b}
	\fi
}
\newcommand\Mn[2][\K]{\mathcal M_{#2}(#1)}
\def\Pmatrix#1{\begin{pmatrix}#1\end{pmatrix}}


%%%%%% Alternatives plus modernes 
\NewDocumentCommand\MN{E{_}{\dimsymb}D(){\corpssymb}}{%
	\opn{\Msymb}_{#1}(#2)%
}
\NewDocumentCommand\GL{sE{_}{\dimsymb} D(){\corpssymb}}{%
	\IfBooleanTF{#1}
		{\opn{\mathrm{GL}}(#3)}
		{\opn{\mathrm{GL}}_{#2}(#3)}%
}
\def\map@mathcal#1#2{%
	\ifblank{#2}{\cal@ #1}{\cal@ #1,\cal@ #2}%
}
\NewDocumentCommand\MAT{s>{\SplitList{,}}E{_}{B} D(){u}}{%
	\IfBooleanTF{#1}{\let\cal@\relax}{\let\cal@\mathcal}
	\opn{Mat}_{\map@mathcal #1}(#2)
}
\NewDocumentCommand\PASS{s E{_^}{{B}{B'}}}{
	\IfBooleanTF{#1}{\let\cal@\relax}{\let\cal@\mathcal}
	P_{\mathcal #1}^{\mathcal #2}
}
\NewDocumentCommand\DET{s E{_}{{B}} d()}{}


%% fonction
%\newcommand{\fct}[4]{\begin{array}[t]{rcl}
%   #1 & \longrightarrow & #2 \\
%   #3 & \longmapsto     & #4 
%   \end{array}}
%






    
\endinput
